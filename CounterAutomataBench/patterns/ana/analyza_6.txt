\\\\hspace\\{0.25em\\}
\\\\hspace\\{0.33em\\}
\\\\hspace\\{0.6em\\}
\\\\hspace\\{1em\\}
\\\\Http[a-z]+ActionInterface$
\\\\hyperref\\[(\\\\detokenize{)?contents:huygens(})?\\]
\\\\hyphenation\\[.*
\\\\hyphenation\\{
\\\\char\"(\\p{ASCII_Hex_Digit}+)
\\\\Chi 
\\\\i 
\\\\I
\\\\i
\\\\i\\b
\\\\if
\\\\iisnode\\\\
\\\\image 
\\\\IMAGE
\\\\implies
\\\\import\\s+([^}]+)
\\\\in 
\\\\in
\\\\include
\\\\include\\{([^}]*)(\\.tex)?\\}
\\\\includegraphics
\\\\includegraphics(.*?){(.*?)}
\\\\includegraphics([^{]*?)\\{([^.]{1,50}?\\.pdf)\\}
\\includegraphics\\[.+\\]\\{([^}]+)\\}
\\index.js?$
\\\\index\\{(\\S+)\\}
\\\\infty 
\\inFunc:\\s*(\\S+)
\\\\input
\\\\input *(harv|lanl)mac
\\\\input texinfo
\\\\input\\s+([\\.\\/\\w]+)
\\\\input\\s+amstex
\\\\input\\s+phyzzx
\\\\insrsid\\d* ?
\\\\inst
\\\\institute
\\\\int 
\\\\int\\\\!\\\\int 
\\\\int\\\\!\\\\int\\\\!\\\\int 
\\\\int\\\\left\\((.+?),(.+?),(.+?)\\\\right\\)
\\\\int\\\\left\\((.+?d[a-z])\\\\right\\)
\\\\Integer
\\\\intercal 
\\\\Interceptor$
\\\\iota 
\\\\Iota 
\\IPv4 Address(.+?)([0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+)$
\\\\it\\s*
\\\\item 
\\\\item
\\\\item \\d
\\\\item\\[(.*?)]{(.*?)}
\\\\item\\s((.|\\n)*?)(?=(\\\\item|\\\\end))
\\js$
\\\\jupiter 
\\\\k\\{\\}
\\\\k\\{A\\}
\\\\k\\{a\\}
\\\\k\\{E\\}
\\\\k\\{e\\}
\\\\k\\{i\\}
\\\\k\\{I\\}
\\\\k\\{U\\}
\\\\k\\{u\\}
\\\\k<(.*?)>
\\\\k<([\\w$]+)>
\\k<a
\\k<a>
\\k<ab\\u003B\\u{003B}c>
\\\\Kappa 
\\\\kappa 
\\\\Koppa 
\\\\l 
\\\\L 
\\\\L
\\\\l
\\\\l (.*?) (?:\\\\l|\\\\n)\n              
\\L$conr
\\L$ownr.$indr
\\L$ownr.$tabl
\\\\l(.)
\\\\L(.*?)(\\\\E|$)
\\\\L\\$([1-9])
\\\\l\\$([1-9])
\\l\\n
\\\\label\\{(.*?)\\}
\\\\label\\{(\\w+)\\}
\\\\label{(\\\\detokenize{)?contents:huygens(})?}}
\\\\Lambda 
\\\\lambda 
\\\\lang[a-z]*\\d* ?
\\\\langle 
\\\\Large
\\\\lastrow\\n\\\\row$
\\\\lazysinv 
\\\\lbrace 
\\\\lccode(`\\\\?\\^\\^|\")($X$X)=(`\\\\?\\^\\^|\")($X$X)
\\\\lceil 
\\\\ldots 
\\\\ldots
\\\\Leftarrow 
\\\\leftarrow 
\\\\leftarrowtail 
\\\\LeftDownTeeVector 
\\\\LeftDownVectorBar 
\\\\leftharpoondown 
\\\\leftharpoonup 
\\\\leftleftarrows 
\\\\Leftrightarrow 
\\\\leftrightarrow 
\\\\leftrightarrows 
\\\\leftrightharpoons 
\\\\leftrightsquigarrow 
\\\\LeftRightVector 
\\\\LeftTeeVector 
\\\\leftthreetimes 
\\\\LeftTriangleBar 
\\\\LeftUpDownVector 
\\\\LeftUpTeeVector 
\\\\LeftUpVectorBar 
\\\\LeftVectorBar 
\\\\lemref{(.*?)}
\\\\leo 
\\\\leq 
\\\\leq
\\\\leqq 
\\\\leqslant 
\\\\lessapprox 
\\\\lessdot 
\\\\lesseqgtr 
\\\\lesseqqgtr 
\\\\lessequivlnt 
\\\\lessgtr 
\\\\let\\\\(\\w+)=(\\^\\^|\")($X$X)
\\\\lfloor 
\\\\libra 
\\\\lim\\\\left\\((.+?),(.+?),(.+?)\\\\right\\)
\\\\List.Real
\\\\list\\s(.*)$
\\\\ll 
\\\\llcorner 
\\\\Lleftarrow 
\\\\lmoustache 
\\\\lnapprox 
\\\\lneq 
\\\\lneqq 
\\\\lnot 
\\\\lnsim 
\\log\\/pancake_
\\\\log\\\\left\\((.+?),(.+?)\\\\right\\)
\\\\Longleftarrow 
\\\\longleftarrow 
\\\\longleftrightarrow 
\\\\Longleftrightarrow 
\\\\longmapsto 
\\\\longrightarrow 
\\\\Longrightarrow 
\\\\looparrowleft 
\\\\looparrowright 
\\\\lozenge 
\\\\lrcorner 
\\\\Lsh 
\\\\lstinline\\[breaklines=true\\](\\S)
\\\\ltimes 
\\\\lvertneqq 
\\\\m
\\\\M
\\\\m=\"(.*?)\"\n              
\\Macintosh\\b
\\\\madda\\{\\}
\\\\madda{}
\\\\male 
\\\\mapsto 
\\\\maq\\{\\}
\\\\maq\\{\\}(\\\\vow\\{aN\\})
\\\\maq{}
\\\\maq{}(\\\\vow{aN})
\\\\mathbb\\{C\\}
\\\\mathbb\\{H\\}
\\\\mathbb\\{N\\}
\\\\mathbb\\{P\\}
\\\\mathbb\\{Q\\}
\\\\mathbb\\{R\\}
\\\\mathbb\\{Z\\}
\\\\mathbin\\{\\{:\\}\\\\!\\\\!\\{\\-\\}\\\\!\\\\!\\{:\\}\\}
\\\\mathfrak\\{C\\}
\\\\mathfrak\\{H\\}
\\\\mathfrak\\{I\\}
\\\\mathfrak\\{R\\}
\\\\mathfrak\\{Z\\}
\\\\mathchar\"2208
\\\\mathrm\\{\\\\ddot\\{I\\}\\}
\\\\mathrm\\{\\\\ddot\\{Y\\}\\}
\\\\mathrm\\{\\\\mu\\}
\\\\mathrm\\{'\\\\Omega\\}
\\\\mathrm\\{'Y\\}
\\\\mathscr\\{B\\}
\\\\mathscr\\{E\\}
\\\\mathscr\\{e\\}
\\\\mathscr\\{F\\}
\\\\mathscr\\{g\\}
\\\\mathscr\\{H\\}
\\\\mathscr\\{I\\}
\\\\mathscr\\{L\\}
\\\\mathscr\\{l\\}
\\\\mathscr\\{M\\}
\\\\mathscr\\{o\\}
\\\\mathscr\\{R\\}
\\\\mbox
\\\\mbox\\{\\\\texteuro\\} 
\\\\mbox{abs}\\\\left\\((.+?)\\\\right\\)
\\\\measuredangle 
\\Media and Data Integrity Errors\\: (.*)\\n
\\\\medskip
\\\\mercury 
\\\\method (?P<id>\\\\?[a-z0-9_]+)(?P<args>\\(.*\\))$
\\\\mho 
\\\\Microsoft SDKs\\\\Windows Phone\\\\v(\\d+\\.\\d+)\\s*InstallationFolder\\s+REG_SZ\\s+(.*)
\\\\Microsoft SDKs\\\\Windows\\\\v(\\d+\\.\\d+)\\s*InstallationFolder\\s+REG_SZ\\s+(.*)
\\\\mid 
\\\\midrule
\\\\mkern1mu 
\\\\mkern4mu 
\\\\mnt\\\\([A-Za-z])
\\Mobile(?:.+)Firefox\\b
\\\\Mock$
\\module.css$
\\\\moduleref (?P<id>[a-z]+)$
\\\\Modules\\\\$
\\\\mp 
\\\\mu 
\\\\multicolumn{(.*?)}{(.*?)}{(.*)}
\\\\multimap 
\\\\multirow{(.*)}\\[.*\\]{(.*)}{(.*)}
\\\\multirow{(.*)}{(.*)}{(.*)}
\n                                 (?<!$c)\n                                 (?:\n                                   (?:($cc([:-]) $cc (?:\\2$cc){4}){1}) |\n                                   (?:($cccc(\\.)$cccc\\.$cccc){1})\n                                 )\n                                 (??{ ($4 eq '.') ? '(?<!\\..{14})' : '(?<!'.$2.'.{17})' })\n                                 (?!(??{ ($4 eq '.') ? '\\.' : $2 })|$c) #collapse this to 1 eval\n                            
\n                                ^\n                                # Match a content type <application>/<type>\n                                (?P<content_type>[-a-zA-Z0-9.]+/[-a-zA-Z0-9.]+)\n                                # Match any character set and encoding\n                                (?:(?:;charset=(?:[-a-zA-Z0-9]+)(?:;(?:base64))?)\n                                  |(?:;(?:base64))?(?:;charset=(?:[-a-zA-Z0-9]+))?)\n                                # Assume the rest is data\n                                ,.*\n                                $\n                                
\n                                ^diff[ ]--git\n                                    [ ](?P<a_path_fallback>\"?a/.+?\"?)[ ](?P<b_path_fallback>\"?b/.+?\"?)\\n\n                                (?:^old[ ]mode[ ](?P<old_mode>\\d+)\\n\n                                   ^new[ ]mode[ ](?P<new_mode>\\d+)(?:\\n|$))?\n                                (?:^similarity[ ]index[ ]\\d+%\\n\n                                   ^rename[ ]from[ ](?P<rename_from>.*)\\n\n                                   ^rename[ ]to[ ](?P<rename_to>.*)(?:\\n|$))?\n                                (?:^new[ ]file[ ]mode[ ](?P<new_file_mode>.+)(?:\\n|$))?\n                                (?:^deleted[ ]file[ ]mode[ ](?P<deleted_file_mode>.+)(?:\\n|$))?\n                                (?:^index[ ](?P<a_blob_id>[0-9A-Fa-f]+)\n                                    \\.\\.(?P<b_blob_id>[0-9A-Fa-f]+)[ ]?(?P<b_mode>.+)?(?:\\n|$))?\n                                (?:^---[ ](?P<a_path>[^\\t\\n\\r\\f\\v]*)[\\t\\r\\f\\v]*(?:\\n|$))?\n                                (?:^\\+\\+\\+[ ](?P<b_path>[^\\t\\n\\r\\f\\v]*)[\\t\\r\\f\\v]*(?:\\n|$))?\n                            
\n                               ^\n                               # Match a content type <application>/<type>\n                               (?P<content_type>[-a-zA-Z0-9.]+/[-a-zA-Z0-9.]+)\n                               # Match any character set and encoding\n                               (?:(?:;charset=(?:[-a-zA-Z0-9]+)(?:;(?:base64))?)\n                                 |(?:;(?:base64))?(?:;charset=(?:[-a-zA-Z0-9]+))?)\n                               # Assume the rest is data\n                               ,.*\n                               $\n                               
\n                            # Processing instruction:\n                            <[?]xml\n                        |\n                            # Document type declaration:\n                            <!DOCTYPE\n                        |\n                            # Reasonable approximation of a tag:\n                            <[:_\\p{IsAlphabetic}][-:.\\w]\n                     
\n                            @\n                            (?P<name>(?:\\w|-)+\n                                     (?:\\[(?:\\w|-)+\\])?)\n                            (?P<rest>.*)\n                          
\n                            \\s*(?P<parameter>[^=]+?)\\s*=\\s*  # parameter (ws-stripped), before '='\n                            (?P<value>[^;]*)                # value (stop before comment=;)\n                            (?P<comment>\\s*;.*)?            # optional comment\n                            
\n                           \\\\begin\\{verbatim\\}\n                             .* \\Q$line\\E .*\n                           \\\\end\\{verbatim\\}\n                          
\n                         (%d(?:
\n                        (?<=[^!*+,/:;<=>@\\\\\\\\_|-])  # cannot be before\n                        --\n                        (?=[^!*+,/:;<=>@\\\\\\\\_|-])   # cannot be after\n                   
\n                        ^PokerStars\\s+                                # Poker Room\n                        Hand\\s+\\#(?P<ident>\\d+):\\s+                   # Hand history id\n                        (Tournament\\s+\\#(?P<tournament_ident>\\d+),\\s+ # Tournament Number\n                         ((?P<freeroll>Freeroll)|(                    # buyin is Freeroll\n                          \\$?(?P<buyin>\\d+(\\.\\d+)?)                   # or buyin\n                          (\\+\\$?(?P<rake>\\d+(\\.\\d+)?))?               # and rake\n                          (\\s+(?P<currency>[A-Z]+))?                  # and currency\n                         ))\\s+\n                        )?\n                        (?P<game>.+?)\\s+                              # game\n                        (?P<limit>(?:Pot\\s+|No\\s+|)Limit)\\s+          # limit\n                        (-\\s+Level\\s+(?P<tournament_level>\\S+)\\s+)?   # Level (optional)\n                        \\(\n                         (((?P<sb>\\d+)/(?P<bb>\\d+))|(                 # tournament blinds\n                          \\$(?P<cash_sb>\\d+(\\.\\d+)?)/                 # cash small blind\n                          \\$(?P<cash_bb>\\d+(\\.\\d+)?)                  # cash big blind\n                          (\\s+(?P<cash_currency>\\S+))?                # cash currency\n                         ))\n                        \\)\\s+\n                        -\\s+.+?\\s+                                    # localized date\n                        \\[(?P<date>.+?)\\]                             # ET date\n                        
\n                       \\G               # last pos matched\n                       (?:\n                        [ \\t]*\n                        ( [\\$\\@\\%] )    # variable type\n                        ( [^\\W\\d]\\w* )  # only allows valid Perl variable names\n                        [ \\t]*\n                        # if we have a default arg we'll suck up\n                        # any comment it has as part of the default\n                        # otherwise explcitly search for a comment\n                        (?:\n                         (?:              # this entire entire piece is optional\n                           =>\n                          ( [^\\n]+? )     # default value\n                         )\n                         |\n                         (?:              # an optional comment\n                          [ \\t]*\n                          \\#\n                          [^\\n]*\n                         )\n                        )?\n                        (?= $ending )\n                        |\n                        [ \\t]*          # a comment line\n                        \\#\n                        [^\\n]*\n                        (?= $ending )\n                        |\n                        [ \\t]*          # just space\n                       )\n                       (\\n |          # newline or\n                          (?= <\\/%\\Q$p->{block_type}\\E> ) )   # end of block (don't consume it)\n                      
\n                     (?:^|\\s)\n                     (\n                      (?:\n                       # A::B::C.meth\n                       
\n                     \\s*(?P<GROUPNUMBER>\\d+)      # group number\n                     \\s+(?P<GROUPNAME>[^\\s]+)\\s*: # group name, separator ':'\n                     \\s*(?P<NATOMS>\\d+)\\satoms    # number of atoms in group\n                     
\n                    # Alias of the form //alias ...\n                    //(?P<alias>[^/]+) (?P<alias_after>.*)\n                |\n                    # Absolute URL (e.g., https://...) not at start.\n                    .* [:/] (?P<url> \\w {2,} :// .*)\n                |\n                    # Keyword at path-component boundary.\n                    (?P<key_before> ^ | .*? /)\n\n                    # Avoid single-character drive letters like C:.\n                    (?P<key> \\w {2,}) :\n\n                    # After the colon, must not have two slashes.\n                    (?P<key_after> .? $ | [^/] .* | / [^/] .*)\n            
\n                    (?: \\A | [^\\\\] )\n                    (?: \\\\{2} )*\n                    [@\\$]\n                    [{]?\n                    ([\\w:]*)\n                    ::\n                
\n                    (?x)( # identify http or https links within href\n             (http|https) # make sure we find a resource type\n                      :// # ...needs to be followed by colon-slash-slash\n                       .* # followed by anyting\n                        ) # end of match group\n                           
\n                    (\\\"(?:\\\\\\\\|\\\\\"|[^\"])*\\\")\n                    |\n                    (\\{[^{}]*(?2)?\\})\n                    |\n                    ([^;=]+)\n                
\n                    (\n                        -- .*                               (?# matches \"--\" style comments to the end of line or string )\n                        |   -                                   (?# matches single \"-\" )\n                        |\n                        /[*] .*? [*]/                       (?# matches C-style comments )\n                        |   /                                   (?# matches single slash )    \n                        |\n                        ' ( [^'\\\\]  |  ''  |  \\\\. )* '  (?# match strings surrounded by apostophes )\n                        |\n                        \" ( [^\"\\\\]  |  \"\"  |  \\\\. )* \"      (?# match strings surrounded by \" )\n                        |\n                        \\?\\??                               (?# match one or two question marks )\n                        |\n                        [^-/'\"?]+                           (?# match all characters except ' \" ? - and / )\n\n                )
\n                    \"?\\Q$local_col\\E\"? \\s* (?:\\w+\\s*)* (?: \\( \\s* \\d\\+ (?:\\s*,\\s*\\d+)* \\s* \\) )? \\s*\n                    references \\s+ (?:\\S+|\".+?(?<!\")\") (?:\\s* \\( \\s* \"?\\Q$remote_col\\E\"? \\s* \\))? \\s*\n                    (?:(?:\n                      on \\s+ (?:delete|update) \\s+ (?:set \\s+ null|set \\s+ default|cascade|restrict|no \\s+ action)\n                    |\n                      match \\s* (?:\\S+|\".+?(?<!\")\")\n                    ) \\s*)*\n                    ((?:not)? \\s* deferrable)?\n                
\n                    \\[GNUPG:\\]\\ ATTRIBUTE\n                    \\ \\w+                   # fingerprint\n                    \\ (?P<octets>\\d+)\n                    \\ (?P<attrtype>\\d+)\n                    \\ (?P<index>\\d+)\n                    \\ (?P<count>\\d+)\n                    \\                       # ... don't care about the rest\n                
\n                    ^/               # comment started like /*/\n                    \\s*\n                    (\\S[\\s\\S]+?)  # has at least some non-ws content\n                    \\s*\n                    /\\*             # ends like /*/ or /**/\n                
\n                    ^\n                    (?P<key>[^\\ ]*)\\ *\n                    (base-fret\\ *(?P<basefret>\\d{1,2}))?\\ *\n                    frets\\ *(?P<frets>((\\d+|x|X)\\ *)+)\\ *\n                    (fingers\\ *(?P<fingers>(([0-4-])\\ *)*))?\n                    $\n                
\n                    <img \\s+[^>]*\n                        src\\s*=\\s*\n                            (?:\n                                (?# Match quoted attribute)\n                                (['\"])file://(?P<quoted>[^\"]+)\\1\n\n                                (?# Match unquoted attribute, which may not contain spaces)\n                            |   file://(?P<unquoted>[^>\\s]+)\n                        )\n                    [^>]* >
\n                    <img \\s+[^>]*\n                        src\\s*=\\s*\n                            (?:\n                                (?# Match quoted attribute)\n                                (['\"])file://(?P<quoted>[^>]+)\\1\n\n                                (?# Match unquoted attribute, which may not contain spaces)\n                            |   file://(?P<unquoted>[^>\\s]+)\n                        )\n                    [^>]* >
\n                  (?:  \\G | [^\\\\]  )  #not esc\n                  
\n                  (?:\n                   \\G |\n                   [^\\\\c-] |\n                   (?>\\G|[^\\\\])c |\n                   (?> [^CM] | (?>\\G|[^\\\\])[CM] )-\n                  )              #not esc\n                  
\n                  (\\PM)($re)($re)($re)\n              }
\n                  (\\PM)($re)($re)\n              }
\n                  (\\PM)($re)\n              }
\n                 ((?!
\n                 (?P<aa>([ACDEFGHIKLMNPQRSTVWY])   # 1-letter amino acid\n                        |                          #   or\n                        ([A-Z][A-Z][A-Z][A-Z]?)    # 3-letter or 4-letter residue name\n                 )\n                 (?P<resid>\\d+)                    # resid\n                 (:                                # separator ':'\n                   (?P<atom>\\w+)                   # atom name\n                 )?                                # possibly one\n            
\n                (.*?)                   # preamble\n                ^--\\Q$boundary\\E\\s*\n                (.+)                    # all parts\n                ^--\\Q$boundary\\E--\\s*\n                (.*)                    # epilogue\n                
\n                (?: \\$\\{ | \\{\\$ ) [^}]++ \\}\n                |\n                \\$\\$?[a-zA-Z_]\\w*\n            
\n                (?: \\A | [^\\\\] )\n                (?: \\\\{2} )*\n                \\\\ [tnrfbae01234567xcNluLUEQ]\n            
\n                (?:(?P<user>[^:@]+)(?::(?P<password>[^:@]+))?@)?\n                (?P<host>[^:]+)\n                (?::(?P<port>[0-9]+))?\n            
\n                (?:\n                    \\(\\?\\(\n                  | \\[ [^\\]\\\\]* (?: \\\\ . [^\\]\\\\]* )* \\]\n                  | \\\\ .\n                ) (*SKIP)(*FAIL) |\n                \\(\n                (?!\n                    \\? (?! <(?![!=]) | P< | ' )\n                  | \\*\n                )\n            
\n                (?:\n                    \\(\\?\\(\n                  | \\[ [^\\]\\\\]* (?: \\\\ . [^\\]\\\\]* )* \\]\n                  | \\\\ .\n                ) (*SKIP)(*FAIL) |\n                \\(\n                (?!\n                    \\?\n                    (?!\n                        <(?![!=])\n                      | P<\n                      | '\n                    )\n                  | \\*\n                )\n            
\n                (?:\\n(?<indent>(?:[ ]{4})*)\\n|\\A\\n?)\n                (?<code>                    # $1 = the code block -- one or more lines, starting with a space/tab\n                    (?:(?>\n                        ^\\g{indent}[ ]{4}   # Lines must start with a tab or a tab-width of spaces\n                        .*\\n\n                    ))*\n                    (?:(?>\n                        ^\\g{indent}[ ]{4}   # Lines must start with a tab or a tab-width of spaces\n                        .*\n                    ))\n                )\n            
\n                (?<!\\\\)\\$ (?: \\((\\w+)\\) | (\\w+) ) # $2 => $(var) | $3 => $var\n\n            } 
\n                (?<command> [^\\s\"']+ ){0}\n                (?<exceptDoubleQuotes> [^\"\\\\]*(?:\\\\.[^\"\\\\]*)* ){0}\n                (?<exceptSingleQuotes> [^'\\\\]*(?:\\\\.[^'\\\\]*)* ){0}\n                \\g<command>|\"\\g<exceptDoubleQuotes>\"|'\\g<exceptSingleQuotes>'\n            
\n                ([\\x
\n                (\n                    <!                  # Match the start of a comment\n                    (-{2})?             # IE can understand comments without dashes\n                    \\[                  # Match the start (\"[\" is a metachar => escape it)\n                        (?:(?!\\]>).)*   # Match everything except \"]>\"\n                    \\]>                 # Match end\n                )\n                (\n                    (?:\n                        (?!<!\\[endif\\]-{2}?>)\n                    .)*\n                )                     # Match everything except end of conditional comment\n                (\n                    <!\\[endif\\]\n                          (?:\\2|(?=>))  # Use a trick to ensure that when dashes are captured they are...\n                                        # matched at the end! Else make sure that the next char is a \">\"!\n                    >                   # Match the endif with the captured dashes\n                )\n            
\\\n                (^|[~\\\\\\\\])\n                @(full_content|\\\n                    first_line|\\\n                    id|\\\n                    node_path|\\\n                    storage_name|\\\n                    storage_path|\\\n                    (meta\\\\{([^\\\\}]+)\\\\}))
\n                \\?\n\n                ( if
\n                \\A\n                \\Qhttp://projecteuler.net/index.php?section=problems&id=\\E\n                \\d+\n                \\z\n            
\n                \\G\n                \\(\n                    (?P<options>\n                        (?:\n                            \\ *?\n                            (?P<name>[a-zA-Z][a-zA-Z0-9_\\-]+)\n                            \\ *?\n                            (?:\\||(?=\\)))\n                            \\ *?\n                        )+\n                    )\n                \\)\n                (?:\\:(?P<groupName>[a-zA-Z0-9]+))?\n                (?:\\ +|$)\n                
\n                \\G\n                \\(\n                    (?P<options>\n                        (?:\n                            \\ *?\n                            \\-+(?P<name>[a-zA-Z0-9][a-zA-Z0-9_\\-]*?)\n                            \\ *?\n                            (?:\\||(?=\\)))\n                            \\ *?\n                        )+\n                    )\n                \\)\n                (?:\\:(?P<groupName>[a-zA-Z0-9]+))?\n                (?:\\ +|$)\n                
\n                \\G\n                \\[\n                    (?P<options>\n                        (?:\n                            \\ *?\n                            (?P<name>[a-zA-Z][a-zA-Z0-9_\\-]*?)\n                            \\ *?\n                            (?:\\||(?=\\]))\n                            \\ *?\n                        )+\n                    )\n                \\]\n                (?:\\:(?P<groupName>[a-zA-Z0-9]+))?\n                (?:\\ +|$)\n                
\n                \\G\n                \\[\n                    (?P<options>\n                        (?:\n                            \\ *?\n                            \\-+(?P<name>[a-zA-Z0-9][a-zA-Z0-9_\\-]*?)\n                            \\ *?\n                            (?:\\||(?=\\]))\n                            \\ *?\n                        )+\n                    )\n                \\]\n                (?:\\:(?P<groupName>[a-zA-Z0-9]+))?\n                (?:\\ +|$)\n                
\n                ^\\s*\n                (?<hidden>-)?\n                (?<name>\n                    [\\p{XPosixAlpha}_]\n                    ([\\p{XPosixAlnum}_])*\n                )\n                \\s*$\n## Please see file perltidy.ERR\n            
\n                =           # start matching by a equal sign\n                \\s*         # its valid to use whitespaces after the equals sign\n                ([\"'])?    # match a single or double quote and make it a capturing group for backreferencing\n                    (\n                            (?:(?=\\1)|[^\\\\])*             # normal part of \"unrolling the loop\". Match no quote nor escaped char\n                            (?:\\\\\\1                       # match the escaped quote\n                                (?:(?=\\1)|[^\\\\])*         # normal part again\n                            )*                              # special part of \"unrolling the loop\"\n                    )       # use a the \"unrolling the loop\" technique to be able to skip escaped quotes like =\"\\\"\"\n                \\1?         # match the same quote symbol as matched before\n            
\n               ([][({})])       # $1 open or close\n             |([:;]-?\\)         # $2 smiley face optional close\n               |\\b[a-zA-Z1-9]\\) #    \"middle a) or 1) item\"\n               |(?<!\\$)\\$\\)     #    perlvar $), and not $$\n               )\n             |([\"'])[][(){}]+\\3 # $3 \"(\" quoted\n             |[:;]-?[(]         # smiley face not an open\n             |(?<!\\$)\\$\\$       # perlvar $$ consumed\n             |\\$\\(\\w*\\)         # makefile var $(abc)\n             |\\$\\[\\w*\\]         # perhaps template $[abc]\n             |(?<!\\$)\\$[][(]    # perlvars $[, $(, $], and not $$\n             |^\\s*(\\d+|[A-Za-z])\\.?\\)   # initial \"1.5) something\"\n             
\n              (\\\\)?         # is it escaped with a backslash?\n              (\\$)          # literal $\n              (?!\\()        # shouldnt be followed by paranthesis\n              (\\{)?         # allow brace wrapping\n              ([A-Z0-9_]+)? # optional alpha nums\n              (\\})?         # closing brace\n            
\n              ^(\n                (\\s*                                  # Possible, but unlikely, space before include statement\n                  \\#include\\s+                        # Include statement\n                  ['\"]                                # Open quote\n                  (.*\\/)?                             # Possible prefix to path\n                  
\n             --(
\n             [
\n            # name attributes\n            \\(?(?P<attributes>.*?)?(?<!\\\\)\\)\\s?\n            # separator\n            \\\"(?P<separator>.*?)\\\"\\s\n            # inbox name with/without separator\n            \\\"?(?P<name>.*?)\\\"?$\n            
\n            %5B       # URL encoded \"[\"\n            (?:       # start non-capturing group\n              (?!%5D) # make sure the next character does not start \"%5D\"\n              [^=&]   # consume the character if it is no \"=\" or \"&\"\n            )*        # end of group; repeat\n            %5D       # URL encoded \"]\"\n            (?=       # lookahead to ensure the match is inside a parameter name\n                      # and not a value\n              [^=&]*= # make sure there is a \"=\" before the next \"&\"\n            )         # end of lookahead\n            
\n            (                         # Outer capture group 1 start\n                json: (\\s*)           # Capture group 2 (space) start\n                (                     # Capture group 3 (braces) start\n                   \\{                 # Opening brace\n                       (?:\n                           [^\\{\\}]++  # Non-braces, no backtrace\n                           | \n                           (?3)       # Recursively capture group 2 (braces)\n                       )*\n                   \\}\n                )\n            )\n        
\n            (                         # Outer capture group 1 start\n                json: (\\s*)           # Capture group 2 (space) start\n                (                     # Capture group 3 (brackets) start\n                   \\[                 # Opening bracket\n                       (?:\n                           [^\\[\\]]++  # Non-brackets, no backtrace\n                           | \n                           (?3)       # Recursively capture group 2 (brackets)\n                       )*\n                   \\]\n                )\n            )\n        
\n            (                   # \\1\n              [ \\t]+\n              (['\"])            # quote char = \\2\n              (?P<title>.*?)\n              \\2\n            )?                  # title is optional\n          \\)$\n        
\n            (''(?!')|\"\"(?!\")|'{6}|\"{6}    # Empty strings (all 4 types)\n             |'(?:[^\\\\']|\\\\.)+?'          # Single quotes (')\n             |\"(?:[^\\\\\"]|\\\\.)+?\"          # Double quotes (\")\n             |'{3}(?:[^\\\\]|\\\\.|\\n)+?'{3}  # Triple-quoted strings (')\n             |\"{3}(?:[^\\\\]|\\\\.|\\n)+?\"{3}  # Triple-quoted strings (\")\n             |\\#.*                        # Comments\n            )
\n            (?: ^ | (?<= [\\{[(;] ) )\n              \\s*\n                (?<source> $expression )\n                  \\s*  ==+>(?<push> >?+ )(?<merge> [<>]?+ )  \\s*\n                (?<action> $expression )\n              \\s*\n            (?= ==+>+ | [\\}\\]);] | $ )\n        }
\n            (?:(?:^::+)|(?P<shebang>^[#]!))\t# Shebang or 2 or more colons.\n            (?P<path>(?:/\\w+)*[/ ])?        # Zero or 1 path\n            (?P<lang>[\\w+-]*)               # The language\n            
\n            (?:(?P<d>[0-9]{1,2})-)?\n            (?P<m>[0-9]{1,2}|\\w{3})\n            -(?P<y>[0-9]{2}(?:[0-9]{2})?)\n            (?:\\s*\\(?\n                (?P<H>[0-9]{2}):(?P<M>[0-9]{2})(?::(?P<S>[0-9]{2}))?\n            \\)?)?
\n            (?<!\\\\)\n            (`+)        # \\1 = Opening run of `\n            (?!`)       # See Note A test/tm-cases/escapes.text\n            (.+?)       # \\2 = The code block\n            (?<!`)\n            \\1          # Matching closer\n            (?!`)\n        
\n            (?<= \\]) # Look behind to find ]\n            (\n                \\(     # match (\n                [^\\)]* # match everything except )\n                \\)     # match )\n            )\n\n            
\n            (?<startString>=>\\s'.*?)?         # optionally assignment operator and starting a string\n            (?P<fullMatch>%                    # an expression is indicated by %\n            (?P<expression>\n            (?:(?:\\\\?[\\d\\w_\\\\]+\\:\\:)         # either a class name followed by ::\n            |                                  # or\n            (?:(?P<prefix>[a-z]+)\\:)           # a prefix followed by : (like \"env:\")\n            )?\n            (?P<name>[A-Z_0-9]+))              # the actual variable name in all upper\n            %)                                 # concluded by %\n            (?<endString>[^%]*?(?:',\\n)?)?    # optionally concluding a string\n        
\n            (?P<env_opening>\n              (?<!\\\\)(?P<dd>\\$\\$) |\n              (?<!\\\\)(?P<sd>\\$) |\n              (?<!\\\\)(?P<braces>\\\\\\() |\n              (?<!\\\\)(?P<braces_sq>\\\\\\[) |\n              \\\\begin\\ *?{\n                (?P<env_name>(?:\n                  equation|align|math|displaymath|eqnarray|gather|flalign|multiline|alignat\n                )\\*?)}\n            )\n\n            (?P<content>\n              (?:\\n|\\\\\\$|[^\\$])+?\n            )\n\n            (?P<env_closing>\n              (?(dd)\\$\\$|(?!)) |\n              (?(sd)\\$|(?!)) |\n              (?(braces)\\\\\\)|(?!)) |\n              (?(braces_sq)\\\\\\]|(?!)) |\n              (?(env_name)\\\\end\\ *?{(?P=env_name)}|(?!))\n            )\n            
\n            (?P<field>[^()<>@,;:\\\"/[\\]?={}\u0001- \u007f]+):[ \t]*\n            (?P<value>[^\u0001-\b\n-\u001f\u007f]*)\r?[ \t]*\r?\n\n        
\n            (?P<name>[\\w\\.\\+]+)://\n            (?:\n                (?P<username>[^:/]*)\n                (?::(?P<password>[^/]*))?\n            @)?\n            (?:\n                (?P<host>[^/:]*)\n                (?::(?P<port>[^/]*))?\n            )?\n            (?:/(?P<database>.*))?\n            
\n            (?P<name>[\\w\\+]+)://\n            (?:\n                (?P<username>[^:/]*)\n                (?::(?P<password>.*))?\n            @)?\n            (?:\n                (?:\n                    \\[(?P<ipv6host>[^/]+)\\] |\n                    (?P<ipv4host>[^/:]+)\n                )?\n                (?::(?P<port>[^/]*))?\n            )?\n            (?:/(?P<database>.*))?\n            
\n            (?P<prefix> [^%]* )\n            % ( \\[ (?P<child> -? \\d+ ) \\] )?\n                ((?P<kind> [^{] ) |\n                 ( [{] (?P<expr> [^}]* ) [}] ))\n        
\n            (?P<prefix> [^%]* )\n            % ( \\[ (?P<child> -? \\d+ ) \\] )?\n                ((?P<type> [^{] ) |\n                 ( [{] (?P<expr> [^}]* ) [}] ))\n        
\n            ([\\s\\[{(]|[
\n            ([\\x
\n            (<p>|.|^)            # start of line?\n            \\!                   # opening\n            (\\<|\\=|\\>)?          # optional alignment atts\n            (
\n            .*                      # any beginning\n            \\[?\\s*                  # possibly optional extra\n            <(?P<final_extra>.*?)>  # capture extra name as final_extra\n            \\s*\\]?\\s*               # with possible end optional indicator\n            $                       # at the very end of spec\n            
\n            [
\n            [^/\\.]+\n            \\.\n            (\n              
\n            \\\\([abfnrtv\\\\?'\"])\n            |\n            \\\\(\\d\\d\\d)\n            |\n            \\\\(x[[:xdigit:]]
\n            \\?fmt\n            \\s*\n            \\{ \\s* ( $path_re ) \\s* }\\s*    # $1\n\n            (                               # $2\n                \\s*\n\n                \\{\n                    (                       # $3\n                        (?: (?> 
\n            \\[ ([^\\[\\]]*?) \\]\n            \\( ((https?://.*?) | (mailto:.*?)) \\)\n            (?! [
\n            \\{(((?>[^\\{\\}]+)|(?R))*)\\}\n        
\n            \\A\n            # 1. Extract the template marker\n            (?:(\\#\\@\\+|\\#\\@\\-)\\n?)?\n\n            # 2. Extract the summary\n            (?:\n              (?! @\\pL ) # The summary may not start with an @\n              (\n                [^\\n.]+\n                (?:\n                  (?! \\. \\n | \\n{2} )     # End summary upon a dot followed by newline or two newlines\n                  [\\n.] (?! [ \\t]* @\\pL ) # End summary when an @ is found as first character on a new line\n                  [^\\n.]+                 # Include anything else\n                )*\n                \\.?\n              )?\n            )\n\n            # 3. Extract the description\n            (?:\n              \\s*        # Some form of whitespace _must_ precede a description because a summary must be there\n              (?! @\\pL ) # The description may not start with an @\n              (\n                [^\\n]+\n                (?: \\n+\n                  (?! [ \\t]* @\\pL ) # End description when an @ is found as first character on a new line\n                  [^\\n]+            # Include anything else\n                )*\n              )\n            )?\n\n            # 4. Extract the tags (anything that follows)\n            (\\s+ [\\s\\S]*)? # everything that follows\n            
\n            \\A\n            # 1. Extract the template marker\n            (?:(\\#\\@\\+|\\#\\@\\-)\\n?)?\n\n            # 2. Extract the summary\n            (?:\n              (?! @\\pL ) # The summary may not start with an @\n              (\n                [^\\n.]+\n                (?:\n                  (?! \\. \\n | \\n{2} )     # End summary upon a dot followed by newline or two newlines\n                  [\\n.]* (?! [ \\t]* @\\pL ) # End summary when an @ is found as first character on a new line\n                  [^\\n.]+                 # Include anything else\n                )*\n                \\.?\n              )?\n            )\n\n            # 3. Extract the description\n            (?:\n              \\s*        # Some form of whitespace _must_ precede a description because a summary must be there\n              (?! @\\pL ) # The description may not start with an @\n              (\n                [^\\n]+\n                (?: \\n+\n                  (?! [ \\t]* @\\pL ) # End description when an @ is found as first character on a new line\n                  [^\\n]+            # Include anything else\n                )*\n              )\n            )?\n\n            # 4. Extract the tags (anything that follows)\n            (\\s+ [\\s\\S]*)? # everything that follows\n            
\n            \\b                             # Word boundary\n            (?P<use_type>use|context)      # use or context keyword\n            \\s+                            # At least one whitespace\n            (?P<id>[a-zA-Z][\\w]*(\\.[a-zA-Z][\\w]*){1,2})\n            (?P<extra>(\\s*,\\s*[a-zA-Z][\\w]*(\\.[a-zA-Z][\\w]*){1,2})*)\n            \\s*                            # Potential whitespaces\n            ;                              # Semi-colon\n    
\n            \\b                    # Word boundary\n            entity                # entity keyword\n            \\s+                   # At least one whitespace\n            (?P<id>[a-zA-Z][\\w]*) # An identifier\n            \\s+                   # At least one whitespace\n            is                    # is keyword\n            
\n            \\b\n            ([:alpha:]+)\n            (
\n            \\n\\s*?\\n\n            (?P<codeblock> \\s*?\n                (?P<prompt> \\>\\>\\>)\n            )\n        
\n            \\QFileNotFoundError: {\"RemoteException\":{\"message\":\"File does not exist:\\E\n        
\n            \\s*                # Any whitespace.\n            (                  # Start capturing here.\n              [^,\"']+?         # Either a series of non-comma non-quote chars.\n              |                # OR\n              \"(?:             # A double-quote followed by a string of chars.\n                  [^\"\\\\]|\\\\.   # That are either non-quotes or escaped...\n               )*              # ...repeated any number of times.\n              \"                # Followed by a closing double-quote.\n              |                # OR\n              '(?:[^'\\\\]|\\\\.)*'# Same as above, for single quotes.\n            )                  # Done capturing.\n            \\s*                # Allow arbitrary space before the comma.\n            (?:,|$)            # Followed by a comma or the end of a string.\n            
\n            ^                             # Beginning of line\n            [\\s]*                         # Potential whitespaces\n            (?P<type_mark>[a-zA-Z][\\w]*)   # An type mark\n            [\\s]*                         # Potential whitespaces\n            (?P<constraint>\\(.*\\))?\n            
\n            ^\n            (\n                ${\\Mail::SPF::Mech->qualifier_pattern}?\n               (${\\Mail::SPF::Mech->name_pattern})\n                [^\\x20]*\n            )\n            (?: \\x20+ | $ )\n        
\n            ^\n            (\n               (${\\Mail::SPF::Mod->name_pattern}) =\n                [^\\x20]*\n            ) \n            (?: \\x20+ | $ )\n        
\n            ^\n            \\[volta\\]\n            \\s+\n            (?P<nanotime>\\S+)\n            \\s+\n            (?P<custom_metric_type>\\S+)\n            \\s+\n            (?P<tag>\\S+)\n            \\s+\n            (?P<message>.*)\n            $\n        
\n            ^\n            \\Q$tag\\E\n            $\n            
\n            ^\n            \\s*\n            (={1,5})\n            \\s*\n            (?P<name>(?:!=+|\n                        [^=!]+|\n                        !)+?\n            )\n            \\s*\n            \\1\n            (?:\\s|\\#|$)\n         
\n            ^\n            create\\s+(?P<name>\\w+)\\s+\n            hash:net\\s+family\\s+inet\\s+\n            hashsize\\s+(?P<hashsize>\\d+)\\s+\n            maxelem\\s+(?P<maxelem>\\d+)\\s*\n            $\n            
\n            ^=head1 \\s+ NAME\n            \\s+\n            \\Q$module\\E \\s+ - \\s+ ([^\\n]+)\n        
\n            <script>\\s*\n            var\\s+funkotron\\s*=\\s*\n            \\{\\s*\n                config\\s*:\\s*(?P<json>\\{.+?\\})\\s*\n            \\}\\s*;?\\s*\n            </script>\n        
\n            url\\(      # url(\n            \\s*\n            ([^\\)]+?)  # 1 = URI (assuming does not contain \")\")\n            \\s*\n            \\)         # )\n        
\n          ' (?: 
\n          # match a specifier, e.g. library or executable\n          ^(
\n          # Match tail of: [text](/url/) or [text](/url/ \"title\")\n          \\(            # literal paren\n            [ \\t]*\n            (?P<url>            # \\1\n                <.*?>\n                |\n                .*?\n            )\n            [ \\t]*\n            (                   # \\2\n              (['\"])            # quote char = \\3\n              (?P<title>.*?)\n              \\3                # matching quote\n            )?                  # title is optional\n          \\)\n        
\n          # Match tail of: [text][id]\n          [ ]?          # one optional space\n          (?:\\n[ ]*)?   # one optional newline followed by spaces\n          \\[\n            (?P<id>.*?)\n          \\]\n        
\n          &(?:\n            n(?:bsp|ot|tilde)|i(?:excl|quest|grave|acute|circ|uml)|c(?:e(?:nt|dil)|urren|opy|cedil)|p(?:ound|lusmn|ara)|y(?:en|acute|uml)|brvbar|s(?:ect|hy|up[123]|zlig)|u(?:ml|grave|acute|circ|uml)|o(?:rd[fm]|grave|acute|circ|tilde|uml|slash)|laquo|r(?:eg|aquo)|m(?:acr|i(?:cro|ddot))|d(?:eg|ivide)|a(?:c(?:ute|irc)|grave|acute|tilde|uml|ring|elig)|frac(?:1[24]|34)|A(?:grave|acute|circ|tilde|uml|ring|Elig)|Ccedil|E(?:grave|acute|circ|uml|TH)|I(?:grave|acute|circ|uml)|Ntilde|O(?:grave|acute|circ|tilde|uml|slash)|t(?:imes|horn)|U(?:grave|acute|circ|uml)|Yacute|THORN|e(?:grave|acute|circ|uml|th)\n            |\\#\\d{4}\n            |\\#x\\h{4}\n          );\n        
\n          (                                               #   $1 total match\n            (
\n          (
\n          ( 0b[10_]+\n          | 0x[0-9a-fA-F-]+\n          | [0-9]+\n          ) (u
\n          (.*)                  # prefix\n          \\b\\w.*                # \"word\" to clear\n          (.{
\n          (/(?:wave|X|Y))\n          (\\s*)(=)(\\s*)\n          (
\n          (/) (\\[
\n          (?![\"#])((?:
\n          (?:
\n          (?:\\ *\\n)*        # leading empty lines\n          (?<indent>\\ {2,})\n          .*?(?:\\n|\\z)      # first line content\n          (\n            \\g<indent>\\ *\n            .*?(?:\\n|\\z)    # rest line content\n            |\n            (?:\\ *\\n)*      # rest empty line\n          )*\n        
\n          (?:\n            (?<number>  -?(?=[1-9]|0(?!\\d))\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)\n            (?<boolean> true | false | null )\n            (?<string>  \" (?:[^\"\\\\]++ | \\\\ [\"\\\\bfnrt\\/] | \\\\ u [0-9a-f]{4} )* \" )\n            (?<array>   \\[ (?> \\g<json> (?: , \\g<json> )* )? \\s* \\] )\n            (?<pair>    \\s* \\g<string> \\s* : \\g<json> )\n            (?<object>  \\{ (?> \\g<pair> (?: , \\g<pair> )* )? \\s* \\} )\n            (?<json>    \\s* (?> \\g<number> | \\g<boolean> | \\g<string> | \\g<array> | \\g<object> ) \\s*)\n          ){0}\n          \\g<object>\n        
\n          (?:^|\\W)                    # beginning of string or non-word char\n          @((?>
\n          (?<backslash>\\\\)?   # is it escaped with a backslash?\n          \\$                  # literal $\n          (?<cmd>             # collect command content for eval\n            \\(                # require opening paren\n            ([^()]|\\g<cmd>)+  # allow any number of non-parens, or balanced\n                              # parens (by nesting the <cmd> expression\n                              # recursively)\n            \\)                # require closing paren\n          )\n        
\n          (?<braces> \\{\n            ([^\\{]+ | \\g<braces>)*  # recursive rule\n          \\})\n        
\n          (?P<PARAGRAPH>\\n\\n)\n        | (?P<SPACE>\\n)\n    
\n          ([\\w*\\s]+?[\\s*]) # return arguments\n          (
\n          ([-+])(\\s*)\n          ([(].*?[)])?(\\s*)\n          (?=
\n          (\\\\)?         # is it escaped with a backslash?\n          (\\$)          # literal $\n          (?!\\()        # shouldnt be followed by paranthesis\n          \\{?           # allow brace wrapping\n          ([A-Z0-9_]+)? # optional alpha nums\n          \\}?           # closing brace\n        
\n          (\\b[snN]?
\n          (\n            (?!\n              url\\(\n            )\n            [^()\\[\\]{}\"'#/ \\t\\r\\n\\f
\n          (\n            \\\\.\n          |\n            (?!url\\()\n            [^\"'/\\#!;\\{\\}] # \"\n          |\n            # interp_uri will handle most url() calls, but not ones that take strings\n            url\\(
\n          (\n            \\/\\*\n            
\n          (\n            \\A [[:punct:]]*     # start of title\n            | [:.;?!][ ]+       # or of subsentence\n            | [ ]['\"
\n          (\n            \\b\n            [[:alpha:]]         # single first letter\n            [\\-
\n          (\n          ^
\n          (^(?:
\n          [
\n          [?](\\\\[MC]-)*     # modifiers\n          (\\\\([\\\\abefnrstv\\#\"']|x[a-fA-F0-9]{1,2}|[0-7]{1,3})|\\S)\n          (?!\\w)\n        
\n          [+-]? # sign\n          (\n            (\\d+[.]\\d*|[.]\\d+)(
\n          [+][+]|--|~|&&|\\band\\b|\\bor\\b|\\bis\\b|\\bisnt\\b|\\bnot\\b|[?]|:|=|\n          [|][|]|\\\\(?=\\n)|(<<|>>>?|==?|!=?|[-<>+*`%&|^/])=?\n        
\n          [0-9]+\n          (
\n          \\\\(?:text|label|mbox|textrm)\n          \\ *?\n          \\{(?:.|\\n)*?\\}\n        
\n          \\(\\s*\\$\\]\\s* \\Q>=\\E \\s* 5[\\d\\._]+ \\s* \\?\\s*\\( \\s*\n          ( [^()]+? ) ,? \\s*\n          \\)\\s*\\:\\s*\\(\\)\\s*\\),\n  
\n          \\[\\[          # start [[\n          ([^\\[\\]]+)    # $text : one or more characters that are not [ or ] ($1)\n          \\]\\]          # end ]]\n        
\n          \\<cds\\.                ## open tag: <cds.\n          ((?:JOURNAL(?P<ibid>ibid)?)  ## a JOURNAL tag\n          |VOL                   ## or a VOL tag\n          |YR                    ## or a YR tag\n          |PG                    ## or a PG tag\n          |REPORTNUMBER          ## or a REPORTNUMBER tag\n          |SER                   ## or a SER tag\n          |URL                   ## or a URL tag\n          |DOI                   ## or a DOI tag\n          |QUOTED                ## or a QUOTED tag\n          |ISBN                  ## or a ISBN tag\n          |PUBLISHER             ## or a PUBLISHER tag\n          |COLLABORATION         ## or a COLLABORATION tag\n          |AUTH(stnd|etal|incl)) ## or an AUTH tag\n          (\\s\\/)?                ## optional /\n          \\>                     ## closing of tag (>)\n          
\n          \\A(?:[^\\r\\n]*coding:[^\\r\\n]*\\r?\\n)?\n          (?<start>
\n          \\A(\n             (^\\s*\\*?\\s*\\n)+\n             (^
\n          \\A(\n             (^\\s*\\n)+\n             (^
\n          \\A\n          (\n            (?:.*[^\\\\]|)  # anything ending not with slash or nothing\n            (?:\\\\\\\\)*     # any number of self escaped slashes\n          )\n          \\{              # open brace\n          (\n            (?:|.*?[^\\\\]) # nothing or non greedy anything ending not with slash\n            (?:\\\\\\\\)*     # any number of self escaped slashes\n          )\n          \\}              # close brace\n          (\n            .*            # what is left\n          )\n          \\z\n        
\n          \\B[{]{2}(\n            ([snN]?
\n          \\b\n          ( 
\n          \\b\n          ([_\\*]*)\n          (?:\n            ( [-\\+\\w]+ [@.\\:\\/] [-\\w@.\\:\\/]+ 
\n          \\n?                 # Optional newline\n          (?<query>           # The media query parameters, this will be $1\n            @media            #   Start with @media\n            (?!\\ -sass-debug-info) # Ignore sass-debug-info\n            [^{]+             #   One to many characters that are not {, we are guaranteed to have a space\n          )\n          {\n          (?<body>            # The actual body, this will be $2\n            (?<braces>        #   Recursive capture group\n              (?:\n                [^{}]*        #     Anything that is not a brace\n                |             #     OR\n                {\\g<braces>}  #     Recursively capture things within braces, this allows for balanced braces\n              )*              # As many of these as we have\n            )\n          )\n          }\n          \\n?                 # Optional newline\n          
\n          \\s*\n          (\n            '(?:[^'\\\\]|\\\\.)*?'|\n            \"(?:[^\"\\\\]|\\\\.)*?\"|\n            `(?:[^`\\\\]|\\\\.)*?`|\n            [a-zA-Z0-9_\\.()]*?\n          )\n          \\s*\n        
\n          \\w+\n          \\s*\n          \\:\n          \\s*\n          (?:\n            \"(?:[^\"\\\\]|\\\\.)*\"\n            |\n            '(?:[^'\\\\]|\\\\.)*'\n            |\n            [^\\s]+\n          )\n        
\n          ^((\\s*;\\s*|\\s+and\\s+)(?P<series>(?:[A-H]|I{1,3}V?|VI{0,3}))?\\s*:?\\s   ## Leading ; : or \" and :\", and a possible series letter\n          \\<cds\\.VOL\\>(?P<vol>\\d+|(?:\\d+\\-\\d+))\\<\\/cds\\.VOL>\\s                  ## Volume\n          \\<cds\\.YR\\>\\((?P<yr>[12]\\d{3})\\)\\<\\/cds\\.YR\\>\\s                       ## year\n          \\<cds\\.PG\\>(?P<pg>[RL]?\\d+[c]?)\\<\\/cds\\.PG\\>)                         ## page\n          
\n          ^(\n             [ \\t]* \\Q${subtest_delim}\\E.*?\n             (?= ^[ \\t]* \\Q${block_delim}\\E | ^[ \\t]* \\Q${subtest_delim}\\E | \\z )\n           )\n        | ^(\n             [ \\t]* \\Q${block_delim}\\E .*?\n             (?= ^[ \\t]* \\Q${block_delim}\\E | ^[ \\t]* \\Q${subtest_delim}\\E | \\z )\n           )\n        | ^( [^\\n]* \\n )\n    
\n          ^(\\Q${cd}\\E.*?(?=^\\Q${cd}\\E|\\z))\n        | ^([^\\n]*\\n)\n    
\\\n         (?P<keyword>part|piece|play|section|voice)|\\\n         (?P<key>([a-zA-Z_][a-zA-Z0-9_#,'=\\\\-]*\\\\s*|:)?:)|\\\n         (?P<ident>[a-zA-Z_][a-zA-Z0-9_ ]*)|\\\n         (?P<string>\"((\\\\\\\\\")|[^\"])*\")|\\\n         (?P<number>[+\\\\-]?\\\\d+)|\\\n         (?P<delim>[{},])|\\\n         (?P<staveline>\\\\|([^;}\\n]*))|\\\n         (?P<comment>//[^\\n]*)|\\\n         (?P<blank>\\n\\\\s*\\n)|\\\n         (?P<newline>\\n)|\\\n         (?P<whitespace>([\\t ]|;)+)|\\\n         (?P<error>.)\\\n         
\\\n         (?P<note>[a-gA-G][=_\\\\#]*[,']*)|\\\n         (?P<part>\\\\*[a-zA-Z_][a-zA-Z0-9_]*)|\\\n         (?P<symbol>[\\\\.\\\\-x\"%])|\\\n         (?P<number>\\\\d+)|\\\n         (?P<barline>\\\\|)|\\\n         (?P<comment>//[^\\n]*)|\\\n         (?P<whitespace>([\\t ]|;)+)|\\\n         (?P<error>.)\\\n         
\n         (\\'.*?(?<=[^\\\\])\\')             |       # single-quoted strings\n         (\\\".*?(?<=[^\\\\])\\\")             |       # double-quoted strings\n         ((?<![\\*\\/])\\/(?![\\/\\*]).*?(?<![\\\\])\\/) # JS regexes, trying hard not to be tripped up by comments\n         
\n         (\n            \\b\n            (?:[bw])?\n            [, ]
\n         <\n         (\\/?)\n         (\n          ($All_Elems)\n          (\\s|$Tag_End|\\Z)   # \\Z) because $) would screw my indentation :)\n         )\n         
\n         <span \\s class=\"category\"[^>]*>\n           \\(\n           For \\s more \\s information \\s\n            .+?       ## non-greedy (smallest possible match\n           \\)\n         <\\/span>\n        
\n        !\n        (?P<device_category>\\d)\n        ECN\n        (?P<model_name>[^/]*)/\n        (?P<iscp_port>\\d{5})/\n        (?P<area_code>\\w{2})/\n        (?P<identifier>.{0,12})\n    
\n        # Captures a set of name/value pairs when used with re.finditer\n        (?P<name>(?:(?=\\w)[^\\d]\\w*))                   # name\n        \\s*=\\s*                                        # =\n        (?P<value>\"(?:\\\\.|\"\"|[^\"])*\"|(?:\\\\.|[^\\s\"])+)  # value\n        
\n        # Grab the traceback header.  Different versions of Python have\n        # said different things on the first traceback line.\n        ^(?P<hdr> Traceback\\ \\(\n            (?: most\\ recent\\ call\\ last\n            |   innermost\\ last\n            ) \\) :\n        )\n        \\s* $                # toss trailing whitespace on the header.\n        (?P<stack> .*?)      # don't blink: absorb stuff until...\n        ^ (?P<msg> \\w+ .*)   #     a line *starts* with alphanum.\n        
\n        # hstore key:\n        # a string of normal or escaped chars\n        \"((?: [^\"\\\\] | \\\\. )*)\"\n        \\s*=>\\s* # hstore value\n        (?:\n            NULL # the value can be null - not catched\n            # or a quoted string like the key\n            | \"((?: [^\"\\\\] | \\\\. )*)\"\n        )\n        (?:\\s*,\\s*|$) # pairs separated by comma or end of string.\n    
\n        # Mantissa\n        (\\#|
\n        # possible space, followed by...\n          (?:\\s*\n          # percent sign, followed by...\n            %\n            # another percent sign, or...\n              (?:%|\n                 # optional assignment suppression flag\n                 \\*?\n                 # optional maximum field width\n                 \\d*\n                   # named character class, ...\n                   (?:\\[\\[:\\w+:\\]\\]|\n                   # traditional character class, or...\n                      \\[[^\\]]*\\]|\n                   # specifier letter.\n                      [
\n        # possible space, followed by...\n          (?:\\s*\n          # percent sign, followed by...\n            %\n            # another percent sign, or...\n              (?:%|\n        \t # optional assignment suppression flag\n        \t \\*?\n        \t # optional maximum field width\n        \t \\d*\n        \t   # named character class, ...\n        \t   (?:\\[\\[:\\w+:\\]\\]|\n        \t   # traditional character class, or...\n        \t      \\[[^\\]]*\\]|\n        \t   # specifier letter.\n        \t      [
\n        # Set-up...\n        (?
\n        # Source consists of a PS1 line followed by zero or more PS2 lines.\n        (?P<command>\n            (?:^(?P<indent> [ ]*) \\$    .*)    # PS1 line\n            (?:\\n           [ ]*  >     .*)*)  # PS2 lines\n        \\n?\n        # Want consists of any non-blank lines that do not start with PS1.\n        (?P<want> (?:(?![ ]*$)    # Not a blank line\n                     (?![ ]*\\$)   # Not a line starting with PS1\n                     .*$\\n?       # But any other line\n                  )*)\n        
\n        # Source consists of a PS1 line followed by zero or more PS2 lines.\n        (?P<source>\n            (?:^  (?P<indent> [ ]*))                   # PS0 line: indent\n            (?:   \\[(?P<label>.+)\\]\\n)?                # PS0 line: label\n            (?:   (?P<user>[\\w]*)@(?P<host>[\\w\\.-]*)\\n)? # PS0 line: user@host\n            (?:   [ ]* \\$ .*)                          # PS1 line\n            (?:\\n [ ]* \\. [ ].*)*)                        # PS2 lines\n        \\n?\n        # Want consists of any non-blank lines that do not start with PS1.\n        (?P<want> (?:(?![ ]*$)    # Not a blank line\n                     (?![ ]*\\$)   # Not a line starting with PS1\n                     .*$\\n?       # But any other line\n                  )*)\n        
\n        # Source consists of a PS1 line followed by zero or more PS2 lines.\n        (?P<source>\n            (?:^(?P<indent> [ ]*) \\$    .*)     # PS1 line\n            (?:\\n           [ ]*  >     .*)*)   # PS2 lines\n        \\n?\n        # Want consists of any non-blank lines that do not start with PS1.\n        (?P<want> (?:(?![ ]*$)    # Not a blank line\n                     (?![ ]*\\$)   # Not a line starting with PS1\n                     .*$\\n?       # But any other line\n                  )*)\n        
\n        # Source consists of a PS1 line followed by zero or more PS2 lines.\n        (?P<source>\n            (?:^(?P<indent> [ ]*) >>>    .*)    # PS1 line\n            (?:\\n           [ ]*  \\.\\.\\. .*)*)  # PS2 lines\n        \\n?\n        # Want consists of any non-blank lines that do not start with PS1.\n        (?P<want> (?:(?![ ]*$)    # Not a blank line\n                     (?![ ]*>>>)  # Not a line starting with PS1\n                     .*$\\n?       # But any other line\n                  )*)\n        
\n        # Source consists of a PS1 line followed by zero or more PS2 lines.\n        (?P<source>\n            (?:^(?P<indent> [ ]*) julia>[ ] .+)    # PS1 line\n            (?:\\n    (?P=indent)? [ ]{7,13} .+)*)  # PS2 lines\n        \\n?\n        # Want consists of any non-blank lines that do not start with PS1.\n        (?P<want> (?:(?![ ]*$)              # Not a blank line\n                     (?![ ]*julia>)         # Not a line starting with PS1\n                     .+$\\n?                 # But any other line\n                  )*)\n        
\n        # start of string, optional whitespace, optional '$'\n        ^\\s*\\$?\n\n        # message (from '$' or start to checksum or end, non-inclusve)\n        (?P<nmea_str>\n            # sentence type identifier\n            (?P<sentence_type>\n\n                # proprietary sentence\n                (P\\w{3})|\n\n                # query sentence, ie: 'CCGPQ,GGA'\n                # NOTE: this should have no data\n                (\\w{2}\\w{2}Q,\\w{3})|\n\n                # taker sentence, ie: 'GPGGA'\n                (\\w{2}\\w{3},)\n            )\n\n            # rest of message\n            (?P<data>[^*]*)\n\n        )\n        # checksum: *HH\n        (?:[*](?P<checksum>[A-F0-9]{2}))?\n\n        # optional trailing whitespace\n        \\s*[\\r\\n]*$\n        
\n        (              # $1: collect all but safety guard at the end\n        \\{             # start of dynamic value\n        (!?)           # $2: use ! to call the method on an object even if :respond_to fails\n        
\n        (           # Start group 1, which is the actual link text\n            \\[          # Match a literal [\n            [^\\]]+      # Match anything except a literal ] - this will be the link text itself\n            \\]          # Match a literal ]\n            \\s*         # Any whitespace (including newlines)\n            \\[          # Match the opening bracket of the lazy link marker\n        )           # End group 1\n        \\*          # Literal * - this is the lazy link marker\n        (           # Start group 2, which is everything after the lazy link marker\n            \\]          # Literal ]\n            .*?^        # Non-greedy match of anything up to a new line\n            \\[          # Literal [\n        )           # End Group 2\n        \\*\\]:       # Match a literal *]: - the lazy link URL definition follows this\n        
\n        (
\n        ( \\d{1,2} )                         # day or month\n        ( \\s | \\- | \\/ | \\\\ | \\_ | \\. )     # separator\n        ( \\d{1,2} )                         # month or day\n        \\2                                  # same separator\n        ( 19\\d{2} | 200\\d | 201\\d | \\d{2} ) # year\n      
\n        ( \\\\U........      # 8-digit hex escapes\n        | \\\\u....          # 4-digit hex escapes\n        | \\\\x..            # 2-digit hex escapes\n        | \\\\[0-7]{1,3}     # Octal escapes\n        | \\\\N\\{[^}]+\\}     # Unicode characters by name\n        | \\\\[\\\\'\"abfnrtv]  # Single-character escapes\n        )
\n        ( \\\\U........      # 8-digit Unicode escapes\n        | \\\\u....          # 4-digit Unicode escapes\n        | \\\\x..            # 2-digit Unicode escapes\n        | \\\\[0-7]{1,3}     # Octal character escapes\n        | \\\\N\\{[^}]+\\}     # Unicode characters by name\n        | \\\\[\\\\'\"abfnrtv]  # Single-character escapes\n        )
\n        (?!
\n        (?:                    # non-capturing group\n          \\A                |  # start of string OR\n          \\r\\n                 # line break\n         )\n        (\n          --
\n        (?:
\n        (?: ^|\\s)\\K               # needs to be sperated by a space\n        $twigil                   # the twigil (ie, $!)\n        (?<varname> \\w+)          # the variable name\n    }
\n        (?: ^|\\s)\\K            # needs to be sperated by a space\n        \\$ __ $marker          # keyword was convert to package\n        _ (?<id> \\d+ ) \\b      # the method name and a word break\n    }
\n        (?:\\$|@{1,2})?            # optional global, instance or class variable indicator\n        (?:
\n        (?:\n            (?&start)\n            (?<names>            (?&word_list)      )\n            (?:\n                  (?: # Boolean\n                      (?<type>     (?&bang) (?&end) ) )\n                | (?: # Counter\n                      (?<argument> (?&optional)?    )\n                      (?<type>     (?&plus) (?&end) ) )\n                | (?: # Scalar types - number, integer, string\n                      (?<argument> (?&arg)          )\n                      (?<subtype>  (?&scalar_type)  )\n                      (?<type>     (?&non_scalar)?  ) )\n                | (?: # Int with default argument\n                      (?<argument> (?&optional)     )\n                      (?<default>  (?&integer)      ) )\n                | (?: # Flag\n                      (?&end)                       ) # Nothing to capture\n            )?\n            (?<garbage> (?&unmatched)? )\n\n            # This ensures that every token is defined, even if only\n            # to the empty string.\n            (?<default>  (?(<default>))  )\n            (?<type>     (?(<type>))     )\n            (?<subtype>  (?(<subtype>))  )\n            (?<argument> (?(<argument>)) )\n        )\n        (?(DEFINE)\n            (?<start>       ^        )\n            (?<word_list>   (?: (?&word) (?: (?&separator) (?&alias) )* ) )\n            (?<word>        \\w[-\\w]* )\n            (?<alias>       (?: [?] | (?&word) ) )\n            (?<separator>   [|]      )\n            (?<scalar_type> (?: [fions] ) )\n            (?<integer>     (?: -? \\d+ ) )\n            (?<arg>         [:=]     )\n            (?<optional>    [:]      )\n            (?<mandatory>   [=]      )\n            (?<non_scalar>  [@%]     )\n            (?<hash>        [%]      )\n            (?<array>       [@]      )\n            (?<bang>        [!]      )\n            (?<plus>        [+]      )\n            (?<end>         (?! . )  )\n            (?<unmatched>   (?: .* $ ) )    # This will be the last thing in an invalid spec\n        )\n    
\n        (?:\n          --\\sC\\slevel\\sbacktrace\\sinformation\\s-------------------------------------------\\n\n          (?:(?:.*\\s)?\\[0x\\h+\\]\\n)*\\n\n        )?\n      
\n        (?:^\\n?[ \\t]*|;[ ])\n        (?P<name>[!#$%&'*+-.0-9A-Z^_`a-z|~]+)\n        =\n        (?P<DQUOTE>\"?)\n            (?P<value>[\\x21\\x23-\\x2b\\x2d-\\x3a\\x3c-\\x5b\\x5d-\\x7e]*)\n        (?P=DQUOTE)\n        (?=\\n?[ \\t]*$|;[ ])\n    
\n        (?:--|\\#)[\\ \\t\\S]*      # single line comments\n        |\n        (?:<>|<=>|>=|<=|==|=|!=|!|<<|>>|<|>|\\|\\||\\||&&|&|-|\\+|\\*(?!/)|/(?!\\*)|\\%|~|\\^|\\?)\n                                # operators and tests\n        |\n        [\\[\\]\\(\\),;.]            # punctuation (parenthesis, comma)\n        |\n        \\'\\'(?!\\')              # empty single quoted string\n        |\n        \\\"\\\"(?!\\\"\")             # empty double quoted string\n        |\n        \".*?(?:(?:\"\"){1,}\"|(?<![\"\\\\])\"(?!\")|\\\\\"{2})\n                                # anything inside double quotes, ungreedy\n\t\t|\n        `.*?(?:(?:``){1,}`|(?<![`\\\\])`(?!`)|\\\\`{2})\n                                # anything inside backticks quotes, ungreedy\n        |\n        '.*?(?:(?:''){1,}'|(?<!['\\\\])'(?!')|\\\\'{2})\n                                # anything inside single quotes, ungreedy.\n        |\n        /\\*[\\ \\t\\n\\S]*?\\*/      # C style comments\n        |\n        (?:[\\w:@]+(?:\\.(?:\\w+|\\*)?)*)\n                                # words, standard named placeholders, db.table.*, db.*\n        |\n        (?:\\${1,2})             # dollars\n        |\n        [\\t\\ ]+                 # any kind of white spaces\n    
\n        (?:web\\+)?diaspora://\n        (
\n        (?<=[^[[:word:]]])r(?<re>\n          \\(\n            (?:\n              (?> [^()]+ )\n              |\n              \\g<re>\n            )*\n          \\)\n        )\n      
\n        (?<comment> /[*] [^*]* [*]+ (?: [^*/] [^*]* [*]+ )* / ){0}\n        (?<ws>      \\g<comment> | \\s                          ){0}\n        (?<ident>   [_a-zA-Z] [0-9_a-zA-Z]*                   ){0}\n        (?<type>    (?: \\g<ident> \\g<ws>+ )* \\g<ident>        ){0}\n        (?<var>     \\g<ident>                                 ){0}\n        \\G          \\g<ws>* \\g<type> \\g<ws>+ \\g<var>\n      
\n        (?<name>
\n        (?<token_string>\n          (?<minus>-)?\n          (?:(?<field_name>\\w+):)?\n          (?:\n            (?:\"(?<quoted_term>.*?)(?<!\\\\)\")\n            |\n            (?<term>\\S+)\n          )\n        )\n      
\n        (?P<domain>\n            (https?:\\/\\/(www\\.)?|www\\.)          # protocol http://, etc\n            [\\-\\w@:%\\.\\+~\\#=]{2,256}\\.[a-z]{2,6} # domain name\n            /?                                   # can have a trailing slash\n        )(?P<path>\n            [\\-\\w@:%\\+\\.~\\#?&/=]*                # rest of path, query, & hash\n        )\n    
\n        (?P<ele>\nH  | He |\nLi | Be | B  | C  | N  | O  | F  | Ne |\nNa | Mg | Al | Si | P  | S  | Cl | Ar |\nK  | Ca | Sc | Ti | V  | Cr | Mn | Fe | Co | Ni | Cu | Zn | Ga | Ge | As | Se | Br | Kr |\nRb | Sr | Y  | Zr | Nb | Mo | Tc | Ru | Rh | Pd | Ag | Cd | In | Sn | Sb | Te | I  | Xe |\nCs | Ba | Hf | Ta | W  | Re | Os | Ir | Pt | Au | Hg | Tl | Pb | Bi | Po | At | Rn |\nFr | Ra | Rf | Db | Sg | Bh | Hs | Mt |\n\nLa | Ce | Pr | Nd | Pm | Sm | Eu | Gd | Tb | Dy | Ho | Er | Tm | Yb | Lu | # Lanthanides\nAc | Th | Pa | U  | Np | Pu | Am | Cm | Bk | Cf | Es | Fm | Md | No | Lr | # Actinides\n        )\n        [^a-z]  # Any specification of an element is followed by some number\n                # or capital letter or special character.\n    
\n        (?P<fence>^(?:~{3,}|`{3,}))[ ]*         # Opening ``` or ~~~\n        (\\{?\\.?(plant)?uml)[ ]*                 # Optional {, and lang\n        # args\n        \\s*(format=(?P<quot>\"|')(?P<format>\\w+)(?P=quot))?\n        \\s*(classes=(?P<quot1>\"|')(?P<classes>[\\w\\s]+)(?P=quot1))?\n        \\s*(alt=(?P<quot2>\"|')(?P<alt>[\\w\\s\"']+)(?P=quot2))?\n        \\s*(title=(?P<quot3>\"|')(?P<title>[\\w\\s\"']+)(?P=quot3))?\n        [ ]*\n        }?[ ]*\\n                                # Optional closing }\n        (?P<code>.*?)(?<=\\n)\n        (?P=fence)[ ]*$\n        
\n        (?P<head> .*? /)\n        (?P<middle> trunk | (tags | branches) (/ guests / [^/@]+)? / [^/@]+)\n        (?P<tail> .*)\n        
\n        (?P<hostname>\\S*)               (?# Capture Hostname)\n        \\suptime\\sis\\s                  (?# Match \" uptime is \")\n        (?P<uptime>[^\\r\\n]*)            (?# Capture until end of line)\n        .*?^System\\simage\\sfile\\sis\\s   (?# Skip until system image line)\n        \"[^:]*(?::/|:)                  (?# Match from quote to ':' or ':/')\n        (?P<sw_image>[^\"]*)             (?# Capture from slash to end quote)\n        .*?^(?i)cisco\\s                 (?# Skip until case insensitive cisco)\n        (?P<model>\\S*)                  (?# Capture model number)\n        .*?^Processor\\sboard\\sID\\s      (?# Skip until 'Processor board')\n        (?P<serial_no>\\S*)\\s            (?# Capture serial number)\n        
\n        (?P<indent> [ ]*)\n        (?P<docprefix> /\\*\\*)\n        (?P<subject>\n            (?P<directive>\n                class|function|data|member|attribute|method|staticmethod\n            )?\n            :\\s*\n            (?P<signature>\n                (?P<name> .+?)\n                (?P<params> \\(.*?\\))?\n            )\n        )\n        \\s*\\n+\n        (?P<body> .+?)\n        \\s*\n        (?P<docsuffix> \\*/)\n    
\n        (?P<ltext>[^\\{\\}]*)\n        (?P<lbrace>\\{)?\n            (?P<lbraces>(?(lbrace)[\\s\\{]*))\n        (?P<mtext>[^\\{\\}]*)\n        (?P<rbrace>\\})?\n            (?P<rbraces>(?(rbrace)[\\s\\}]*))\n        (?P<rtext>[^\\{\\}]*)\n        
\n        (?P<major>\\d+)\n        \\.\n        (?P<minor>\\d+)\n        \\.\n        (?P<release>\\d+)\n        (?P<additional>[abc]\\d+)?
\n        (?P<min>\\d+|\\*)         # Initial value\n        (?:-(?P<max>\\d+))?      # Optional max upper bound\n        (?:/(?P<step>\\d+))?     # Optional step increment\n        
\n        (?P<name>[\\w\\+]+)://\n        (?:\n            (?P<username>[^:/]*)\n            (?::(?P<password>.*))?\n        @)?\n        (?:\n            (?:\n                \\[(?P<ipv6host>[^/]+)\\] |\n                (?P<ipv4host>[^/:]+)\n            )?\n            (?::(?P<port>[^/]*))?\n        )?\n        (?:/(?P<database>.*))?\n        
\n        (?P<name>[\\w\\+]+)://\n        (?:\n        (?P<username>[^:/]*)\n        (?::(?P<password>[^/]*))?\n        @)?\n        (?:\n        (?P<host>[^/:]*)\n        (?::(?P<port>[^/]*))?\n        )?\n        (?:/(?P<database>.*))?\n        
\n        (?P<y>[0-9]{4})\n        -(?P<m>[0-9]{1,2}|\\w{3})\n        (?:-(?P<d>[0-9]{1,2}))?\n        (?:\\s*\\(?\n        (?P<H>[0-9]{2}):(?P<M>[0-9]{2})(?::(?P<S>[0-9]{2}))?\n        \\)?)?
\n        (\\#<<<\\n\n         \\#\\#\\#\\Q :start $name:\\E\\n)\n        .*\n        (\\#\\#\\#\\Q :end $name:\\E\\n\n         \\#>>>\\n)\n    
\n        (\n          (?: ^ | [^\\\\] ) # New line or non-backslash\n          (\\\\{2})*        # Even number of backslashes\n        )\n\n        # All single quotes must have been escaped.  The important bit is to\n        # not lose escaped backslashes.\n        \\\\'\n      
\n        (\n          \\[\n            (
\n        (\n          \\{                           # beginning of comment\n          (\n            [[:print:]&&[^\\\\\\{\\}]] |   # printing characters except brace and backslash\n            \\n                     |\n            \\\\\\\\                   |   # escaped backslashes\n            \\\\\\{|\\\\\\}              |   # escaped braces\n            \\n                     |   # newlines\n            \\g<1>                      # recursive\n          )*                           # zero or more of the above\n          \\}                           # end of comment\n        )\n      
\n        (^\\s*|\\-)\n        (                                # group name\n            (?P<symbol>\\D?)              # one letter amino acid (optional)\n            0*(?P<number>[0-9]+)         # residue number\n            (?P<suffix>[abd-gi-mopr-z]*) # suffix (optional)\n        )?\n        (?P<nucleus>                     # nucleus name (e.g., CA, HG, ...)\n            (?P<atom>[hncq])             # nucleus type\n            [a-z0-9]*                    # nucleus name - nucleus type\n        )?\n    
\n        (href|src)        # Look for either an href=\"\" or src=\"\" attribute\n        =                 # ...followed by an =\n        (\"|'|)            # Then either a single, double or no quote at all\n        (                 # Capture the entire reference\n          [^'\"]+          # Anything but something that would close the attribute\n                          # And then the extension:\n          (\\.(?:
\n        (username|login|u:)\\s*:?\\s*    # username might have : and whitespace\n        (?P<username>[\\w\\-\\.@+]*)      # capture the username for replacement\n        \\s+                            # some whitespace between\n        (password|pw|p:)\\s*:?\\s*       # password might have : and whitespace\n        (?P<password>.*)               # password can be anything until EOL\n    
\n        .*?\n        (\n          
\n        ::uml:: \n        # args\n        \\s*(format=(?P<quot>\"|')(?P<format>\\w+)(?P=quot))?\n        \\s*(classes=(?P<quot1>\"|')(?P<classes>[\\w\\s]+)(?P=quot1))?\n        \\s*(alt=(?P<quot2>\"|')(?P<alt>[\\w\\s\"']+)(?P=quot2))?\n        \\s*(title=(?P<quot3>\"|')(?P<title>[\\w\\s\"']+)(?P=quot3))?\n        \\s*\\n\n        (?P<code>.*?)(?<=\\n)\n        ::end-uml::[ ]*$\n        
\n        [^};]*?\n        {\n            (\n                (\n                    ([^\\{\\}]+)|(?R)\n                )*\n            )\n        }\n        
\n        \\\\ ([nrt'\\\\] | x
\n        \\$(?:\n          (?P<escaped>\\$)              |   # Two $ signs\n          (?P<named>[_a-z][_a-z0-9]*)  |   # $name format\n          {(?P<braced>[^}]*)}              # ${name} format\n        )\n        
\n        \\(\n        (?:
\n        \\.(?!\\d)=? |      # dot that is not decimal point, string concatenation\n        && | \\|\\| |       # logic\n        :: | -> | => |    # scope, member, dictionary\n        \\\\(?!\\n) |        # namespace\n        \\+\\+ | -- |       # increment, decrement\n        [,;?:()\\[\\]{}] |  # simple delimiters\n        [-+*\\/%&|^]=? |   # ordinary math, binary logic, assignment shortcuts\n        [~$] |            # whatever\n        =& |              # reference assignment\n        [=!]=?=? | <> |   # comparison and assignment\n        <<=? | >>=? | [<>]=?  # comparison and shift\n      
\n        \\[                              # opening text\n          ([^\\[\\]]+)                    # annotated text\n        \\]                              # closing text\n        \\(                              # opening annotations\n          ((?:\n            (?:\n              
\n        \\[                    # [\n        ([^\\]]+)              # very permissive!\n        \\]                    # ]\n      
\n        \\[\\% \\s* IF \\s* ([A-Za-z_]+) \\s* \\%\\]\n        \\n?\n        ((?:.*?(?R)?.*?)+)\n        \\n?\n        \\[\\% \\s* END \\s* \\%\\]\n    
\n        \\{\n            (?=(\n                (?P<name>[^{}]+)\n            ))\\1\n        \\}\n        
\n        \\A\n        ( : )\n        ( 0x [\\hx]+ )\n        (?= \\s | \\z )\n      
\n        \\A\n        (?&PerlOWS)\n        (?<type>(?&PerlIdentifier))? (?&PerlOWS)\n        (?<var>(?:(?&PerlVariable)))\n        \\Z\n        $PPR::GRAMMAR\n    
\n        \\A\n        (?<statement>\n            (?&PerlOWS)\n            (?<assign_to>\n                (?<type_varlist>\n                    (?&PerlIdentifier)? (?&PerlOWS)\n                    (?&PerlVariable)\n                |   (?&PerlParenthesesList)\n                ) (?&PerlOWS)\n                (?<attributes>(?&PerlAttributes))? (?&PerlOWS)\n            )\n            (?<eq>=)? (?&PerlOWS)\n            (?<assign>(?&PerlConditionalExpression))?\n        ) $PPR::GRAMMAR 
\n        \\A\n        (\\w+\\.)? # optional prefix key\n        (https?.*?) # URI\n        (\\.
\n        \\A\n        https?://                                        # http:// or https://\n        ([^\\s:@]+:[^\\s:@]*@)?                            # optional username:pw@\n        ( (xn--)?[a-z0-9]+([-.][a-z0-9]+)*\\.[a-z]{2,6}\\.? |  # domain (including Punycode/IDN)...\n            
\n        \\A\\s* # optional leading spaces\n        (<p>\\s*)? # optional opening p tag\n        # any one of our special list types\n        (
\n        \\b                             # Word boundary\n        package                        # package keyword\n        \\s+                            # At least one whitespace\n        body                           # body keyword\n        \\s+                            # At least one whitespace\n        (?P<package>[a-zA-Z][\\w]*)     # A package\n        \\s+                            # At least one whitespace\n        is                             # is keyword\n        
\n        \\b                           # start at word boundary\n         (                           # begin $1  
\n        \\b                    # Word boundary\n        architecture          # architecture keyword\n        \\s+                   # At least one whitespace\n        (?P<id>[a-zA-Z][\\w]*) # An identifier\n        \\s+                   # At least one whitespace\n        of                    # of keyword\n        \\s+                   # At least one whitespace\n        (?P<entity_id>[a-zA-Z][\\w]*) # An identifier\n        \\s+                   # At least one whitespace\n        is                    # is keyword\n        
\n        \\b                    # Word boundary\n        configuration         # configuration keyword\n        \\s+                   # At least one whitespace\n        (?P<id>[a-zA-Z][\\w]*) # An identifier\n        \\s+                   # At least one whitespace\n        of                    # of keyword\n        \\s+                   # At least one whitespace\n        (?P<entity_id>[a-zA-Z][\\w]*) # An identifier\n        \\s+                   # At least one whitespace\n        is                    # is keyword\n        
\n        \\b                    # Word boundary\n        context               # context keyword\n        \\s+                   # At least one whitespace\n        (?P<id>[a-zA-Z][\\w]*) # An identifier\n        \\s+                   # At least one whitespace\n        is                    # is keyword\n        
\n        \\b                    # Word boundary\n        entity                # entity keyword\n        \\s+                   # At least one whitespace\n        (?P<id>[a-zA-Z][\\w]*) # An identifier\n        \\s+                   # At least one whitespace\n        is                    # is keyword\n        
\n        \\b                    # Word boundary\n        package               # package keyword\n        \\s+                   # At least one whitespace\n        (?P<id>[a-zA-Z][\\w]*) # An identifier\n        \\s+                   # At least one whitespace\n        is                    # is keyword\n        
\n        \\b                    # Word boundary\n        type\n        \\s+\n        (?P<id>[a-zA-Z][\\w]*)       # An identifier\n        \\s+\n        is\n        \\s*\\(\\s*\n        (?P<literals>[a-zA-Z][\\w]* # First enumeration literal\n        (\\s*,\\s*[a-zA-Z][\\w]*)*)   # More enumeration literals\n        \\s*\\)\\s*;
\n        \\b                    # Word boundary\n        type\n        \\s+\n        (?P<id>[a-zA-Z][\\w]*)       # An identifier\n        \\s+\n        is\n        \\s+\n        record\n        (?P<elements>.*?)end\\s+record
\n        \\b                    # Word boundary\n        type\n        \\s+\n        (?P<id>[a-zA-Z][\\w]*)\n        \\s+\n        is\n        \\s+\n        array\n        \\s*\\(\n        (?P<ranges>.*?)\n        \\)\\s+of\\s+\n        (?P<subtype_indication>.*?)\\s*;
\n        \\b\n        \\Q@
\n        \\s*(?P<range_attribute>[a-zA-Z][\\w]*'range)\\s*
\n        \\s*(?P<range_left>.+?)\n        \\s+(to|downto)\\s+\n        (?P<range_right>.+?)\\s*
\n        \\s*(?P<range_left1>.+?)\n        \\s+(to|downto)\\s+\n        (?P<range_right1>.+?)\\s*\n        (,\n        \\s*(?P<range_left2>.+?)\n        \\s+(to|downto)\\s+\n        (?P<range_right2>.+?)\\s*)?
\n        \\s*(?P<range_type>[a-zA-Z][\\w]*)\n        \\s+range\\s+<>\\s*
\n        \\s*(?P<range_type1>[a-zA-Z][\\w]*)\n        \\s+range\\s+<>\\s*\n        (,\n        \\s*(?P<range_type2>[a-zA-Z][\\w]*)\n        \\s+range\\s+<>\\s*)?
\n        \\s*\n        <\n            (?P<end>/{0,1})       # end tag e.g.: </end>\n            (?P<tag>[^ >]+)       # tag name\n            .*?\n            (?P<startend>/{0,1})  # closed tag e.g.: <closed />\n        >\n        \\s*\n    
\n        \\s*\n        Pseudopotential type:\\s*(?P<upf_type>.*)\n        
\n        \\s+ - \\s+\n        State \\s+ \"(?P<done> [^\"]+)\" \\s+\n        from  \\s+ \"(?P<todo> [^\"]+)\" \\s+\n        \\[ (?P<date> [^\\]]+) \\]
\n        ^                                       # Linestart\n        [ \\t]*                                  # Optional white space\n        (?P<name>[A-Za-z]+[A-Za-z0-9]{0,2})\\s+   # get the symbol, max 3 chars, starting with a char\n        (?P<x>                                  # Get x\n            [\\-|\\+]?(\\d*[\\.]\\d+ | \\d+[\\.]?\\d*)\n            ([E|e|d|D][+|-]?\\d+)?\n        )\n        [ \\t]+\n        (?P<y>                                  # Get y\n            [\\-|\\+]?(\\d*[\\.]\\d+ | \\d+[\\.]?\\d*)\n            ([E|e|d|D][+|-]?\\d+)?\n        )\n        [ \\t]+\n        (?P<z>                                  # Get z\n            [\\-|\\+]?(\\d*[\\.]\\d+ | \\d+[\\.]?\\d*)\n            ([E|e|d|D][+|-]?\\d+)?\n        )\n        [ \\t]*\n        (?P<fx>[01]?)                           # Get fx\n        [ \\t]*\n        (?P<fy>[01]?)                           # Get fx\n        [ \\t]*\n        (?P<fz>[01]?)                           # Get fx\n        
\n        ^                        # Linestart\n        [ \\t]*                   # Optional white space\n        (?P<x>                   # Get x\n            [\\-|\\+]? ( \\d*[\\.]\\d+ | \\d+[\\.]?\\d*)\n            ([E|e|d|D][+|-]?\\d+)?\n        )\n        [ \\t]+\n        (?P<y>                   # Get y\n            [\\-|\\+]? (\\d*[\\.]\\d+ | \\d+[\\.]?\\d*)\n            ([E|e|d|D][+|-]?\\d+)?\n        )\n        [ \\t]+\n        (?P<z>                   # Get z\n            [\\-|\\+]? (\\d*[\\.]\\d+ | \\d+[\\.]?\\d*)\n            ([E|e|d|D][+|-]?\\d+)?\n        )\n        
\n        ^                   # Beginning of line.\n        Python              # Literally \"Python\".\n        \\s                  # Space.\n        (?P<major>\\d+)      # Major = one or more digits.\n        \\.                  # Dot.\n        (?P<minor>\\d+)      # Minor = one or more digits.\n        (?:                 # Unnamed group for dot-micro.\n            \\.              # Dot.\n            (?P<micro>\\d+)  # Micro = one or more digit.\n        )?                  # Micro is optional because pypa/pipenv#1893.\n        .*                  # Trailing garbage.\n        $                   # End of line.\n    
\n        ^ #beginning of string\n        \\d{${\\NUM_OF_DIGITS_IN_POSTALCODE}} #digits in postalcode\n        $ #end of string\n        
\n        ^ (?P<null> (?i) null $| ~ $)\n        | (?P<bool> (?i) true $| false $| yes $| no $)\n        | (?P<int10> [-+]? [0-9]+ $)\n        | (?P<int8> 0o [0-7]+ $)\n        | (?P<int16> 0x [0-9a-fA-F]+ $)\n        | (?P<float>[-+]? (?:\n            (?: [0-9]* \\. [0-9]+ |  [0-9]+ \\. [0-9]* )\n                (?: [eE] [-+]? [0-9]+ )? $|\n            [0-9]* \\.? [0-9]* [eE] [-+]? [0-9]+ ) $\n          )\n        | (?P<infinity> [-+]? (?: \\.inf | \\.Inf | \\.INF) $)\n        | (?P<nan> [-+]? (?: \\.nan | \\.NaN | \\.NAN) $)\n        | (?P<str> .+ $)\n    
\n        ^ [ \\t]* (?P<name>\\S+) [ \\t]+ (?P<mass>\\S+) [ \\t]+ (?P<pseudo>\\S+)\n            [ \\t]* $\\n?\n        
\n        ^ [ \\t]* ATOMIC_POSITIONS [ \\t]*\n            [{(]? [ \\t]* (?P<units>\\S+?)? [ \\t]* [)}]? [ \\t]* $\\n\n        (?P<block>\n         (?:\n          ^ [ \\t]*\n          (?:\n           \\S+ [ \\t]+ \\S+ [ \\t]+ \\S+ [ \\t]+ \\S+\n           (?:[ \\t]+ [{(]? [ \\t]* [01] [ \\t]+ [01] [ \\t]+ [01] [ \\t]* [)}]?)?\n          )\n          [ \\t]* $\\n?\n         )+\n        )\n        
\n        ^ [ \\t]* ATOMIC_SPECIES [ \\t]* $\\n\n        (?P<block>\n         (?:\n          ^ [ \\t]* \\S+ [ \\t]+ \\S+ [ \\t]+ \\S+ [ \\t]* $\\n?\n         )+\n        )\n        
\n        ^ [ \\t]* K_POINTS [ \\t]*\n            [{(]? [ \\t]* (?P<type>\\S+?)? [ \\t]* [)}]? [ \\t]* $\\n\n        ^ [ \\t]* \\S+ [ \\t]* $\\n  # nks\n        (?P<block>\n         (?:\n          ^ [ \\t]* \\S+ [ \\t]+ \\S+ [ \\t]+ \\S+ [ \\t]+ \\S+ [ \\t]* $\\n?\n         )+\n        )\n        
\n        ^ [ \\t]*\n        CELL_PARAMETERS [ \\t]*\n        [{(]? \\s* (?P<units>[a-z]*) \\s* [)}]? \\s* [\\n]\n        (?P<block>\n        (\n            (\n                \\s*             # White space in front of the element spec is ok\n                (\n                    # First number\n                    (\n                        [-|+]?   # Plus or minus in front of the number (optional)\n                        (\\d*     # optional decimal in the beginning .0001 is ok, for example\n                        [\\.]     # There has to be a dot followed by\n                        \\d+)     # at least one decimal\n                        |        # OR\n                        (\\d+     # at least one decimal, followed by\n                        [\\.]?    # an optional dot\n                        \\d*)     # followed by optional decimals\n                        ([E|e|d|D][+|-]?\\d+)?  # optional exponents E+03, e-05, d0, D0\n                    \n                        (\n                            \\s+      # White space between numbers\n                            [-|+]?   # Plus or minus in front of the number (optional)\n                            (\\d*     # optional decimal in the beginning .0001 is ok, for example\n                            [\\.]     # There has to be a dot followed by\n                            \\d+)     # at least one decimal\n                            |        # OR\n                            (\\d+     # at least one decimal, followed by\n                            [\\.]?    # an optional dot\n                            \\d*)     # followed by optional decimals\n                            ([E|e|d|D][+|-]?\\d+)?  # optional exponents E+03, e-05, d0, D0\n                        ){2}         # I expect three float values\n                    )\n                    |\n                    \\#\n                    |\n                    !            # If a line is commented out, that is also ok\n                )\n                .*               # I do not care what is after the comment or the vector\n                |                # OR\n                \\s*              # A line only containing white space\n             )\n            [\\n]                 # line break at the end\n        ){3}                     # I need exactly 3 vectors\n    )\n    
\n        ^ \\s* ATOMIC_POSITIONS \\s*                      # Atomic positions start with that string\n        [{(]? \\s* (?P<units>\\S+?)? \\s* [)}]? \\s* $\\n    # The units are after the string in optional brackets\n        (?P<block>                                  # This is the block of positions\n            (\n                (\n                    \\s*                                 # White space in front of the element spec is ok\n                    (\n                        [A-Za-z]+[A-Za-z0-9]{0,2}       # Element spec\n                        (\n                            \\s+                         # White space in front of the number\n                            [-|+]?                      # Plus or minus in front of the number (optional)\n                            (\n                                (\n                                    \\d*                 # optional decimal in the beginning .0001 is ok, for example\n                                    [\\.]                # There has to be a dot followed by\n                                    \\d+                 # at least one decimal\n                                )\n                                |                       # OR\n                                (\n                                    \\d+                 # at least one decimal, followed by\n                                    [\\.]?               # an optional dot ( both 1 and 1. are fine)\n                                    \\d*                 # And optional number of decimals (1.00001)\n                                )                        # followed by optional decimals\n                            )\n                            ([E|e|d|D][+|-]?\\d+)?       # optional exponents E+03, e-05\n                        ){3}                            # I expect three float values\n                        ((\\s+[0-1]){3}\\s*)?             # Followed by optional ifpos\n                        \\s*                             # Followed by optional white space\n                        |\n                        \\#.*                            # If a line is commented out, that is also ok\n                        |\n                        \\!.*                            # Comments also with excl. mark in fortran\n                    )\n                    |                                   # OR\n                    \\s*                                 # A line only containing white space\n                 )\n                [\\n]                                    # line break at the end\n            )+                                          # A positions block should be one or more lines\n        )\n        
\n        ^(.*_dependency\n        \\s*(?:\\(\\s*)?\n        (?:['\"]|%q.)
\n        ^(?P<locus>\n            (?:(?P<prefix>\\w+[\\D\\d\\D])\\.?)(?P<chr>[\\d|C|M]+)(?P<sep>[A-z]+)(?P<rank>\\d+)\n        )\n        \\.?(?P<iso>\\d+)?\n        
\n        ^(\\#{1,6})  # \\1 = string of #'s\n        [ \\t]+\n        (.+?)       # \\2 = Header text\n        [ \\t]*\n        (?<!\\\\)     # ensure not an escaped trailing '#'\n        \\#*         # optional closing #'s (not counted)\n        \\n+\n        
\n        ^/(?P<namespace>[^/]+)\n         /(?P<protocol_version>[^/]+)\n         /(?P<transport_id>[^/]+)\n         /(?P<session_id>[^/]+)/?$\n         
\n        ^/(?P<resource>.+?)\n         /(?P<protocol_version>[^/]+)\n         //(?P<sessid>[^/]+)/?$\n         
\n        ^/(?P<resource>.+?)\n         /1\n         /(?P<transport_id>[^/]+)\n         /(?P<sessid>[^/]+)/?$\n         
\n        ^[uU]?[rR]?(?:\n            ( '''\n            | \\\"\\\"\\\"\n            )\n          | ( '[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*(?:'|\\\\\\n)\n            | \"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*(?:\"|\\\\\\n)\n            )\n        )\n        
\n        ^\n        (?:\n            ([0-9A-Za-z]
\n        ^\n        (?P<docprefix> /\\*\\*)\n        \\s*\\n+\n        (?P<body> .+?)\n        \\s*\n        (?P<docsuffix> \\*/)\n    
\n        ^\n        (?P<major>(?:0|[1-9][0-9]*))\n        \\.\n        (?P<minor>(?:0|[1-9][0-9]*))\n        \\.\n        (?P<patch>(?:0|[1-9][0-9]*))\n        (\\-(?P<prerelease>\n            (?:0|[1-9A-Za-z-][0-9A-Za-z-]*)\n            (\\.(?:0|[1-9A-Za-z-][0-9A-Za-z-]*))*\n        ))?\n        (\\+(?P<build>\n            [0-9A-Za-z-]+\n            (\\.[0-9A-Za-z-]+)*\n        ))?\n        $\n        
\n        ^\n        (?P<Year>[0-9]{4})\n        (?P<Month>0[1-9]|1[0-2])\n        (?P<Day>0[1-9]|[12][0-9]|3[01])\n        (?P<Hour>[01][0-9]|2[0-3])\n        (?:\n          (?P<Minute>[0-5][0-9])\n          (?P<Second>[0-5][0-9]|60)?\n        )?\n        (?:\n          [.,]\n          (?P<Fraction>[0-9]+)\n        )?  \n        (?:\n          Z\n          |\n          (?:\n            (?P<Offset>[+-])\n            (?P<OffHour>[01][0-9]|2[0-3])\n            (?P<OffMinute>[0-5][0-9])?\n          )\n        )\n        $\n        
\n        ^\n        (\n          (
\n        ^\n        \\s*\n        (?P<operator>(~=|==|!=|<=|>=|<|>|===))\n        (?P<version>\n            (?:\n                # The identity operators allow for an escape hatch that will\n                # do an exact string match of the version you wish to install.\n                # This will not be parsed by PEP 440 and we cannot determine\n                # any semantic meaning from it. This operator is discouraged\n                # but included entirely as an escape hatch.\n                (?<====)  # Only match for the identity operator\n                \\s*\n                [^\\s]*    # We just match everything, except for whitespace\n                          # since we are only testing for strict identity.\n            )\n            |\n            (?:\n                # The (non)equality operators allow for wild card and local\n                # versions to be specified so we have to define these two\n                # operators separately to enable that.\n                (?<===|!=)            # Only match for equals and not equals\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)*   # release\n                (?:                   # pre release\n                    [-_\\.]?\n                    (a|b|c|rc|alpha|beta|pre|preview)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n\n                # You cannot use a wild card and a dev or local version\n                # together so group them with a | and make them optional.\n                (?:\n                    (?:[-_\\.]?dev[-_\\.]?[0-9]*)?         # dev release\n                    (?:\\+[a-z0-9]+(?:[-_\\.][a-z0-9]+)*)? # local\n                    |\n                    \\.\\*  # Wild card syntax of .*\n                )?\n            )\n            |\n            (?:\n                # The compatible operator requires at least two digits in the\n                # release segment.\n                (?<=~=)               # Only match for the compatible operator\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)+   # release  (We have a + instead of a *)\n                (?:                   # pre release\n                    [-_\\.]?\n                    (a|b|c|rc|alpha|beta|pre|preview)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n                (?:[-_\\.]?dev[-_\\.]?[0-9]*)?          # dev release\n            )\n            |\n            (?:\n                # All other operators only allow a sub set of what the\n                # (non)equality operators do. Specifically they do not allow\n                # local versions to be specified nor do they allow the prefix\n                # matching wild cards.\n                (?<!==|!=|~=)         # We have special cases for these\n                                      # operators so we want to make sure they\n                                      # don't match here.\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)*   # release\n                (?:                   # pre release\n                    [-_\\.]?\n                    (a|b|c|rc|alpha|beta|pre|preview)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n                (?:[-_\\.]?dev[-_\\.]?[0-9]*)?          # dev release\n            )\n        )\n        \\s*\n        $\n        
\n        ^\n        \\s*\n        (?P<operator>(==|!=|<=|>=|<|>))\n        \\s*\n        (?P<version>\n            [^\\s]* # We just match everything, except for whitespace since this\n                   # is a \"legacy\" specifier and the version string can be just\n                   # about anything.\n        )\n        \\s*\n        $\n        
\n        ^\\s*\\K                   # preserve leading whitespace\n        package             \\s+  # method was converted to sub\n        (?<subname> \\w+)\\n  \\s*  # the method name and a newline\n        (?<brace> \\{ .*?)   [ ]* # opening brace on newline followed orig comments\n        \\#__$marker         \\s+  # our magic token\n        (?<id> \\d+)              # our sub identifier\n        [ ]*                     # trailing spaces (not all whitespace)\n    }
\n        ^\\s*\n        (?P<options>     # Match a leading set of name/value pairs\n            (?:\n                (?:(?=\\w)[^\\d]\\w*)                         # name\n                \\s*=\\s*                                    # =\n                (?:\"(?:\\\\.|\"\"|[^\"])*\"|(?:\\\\.|[^\\s\"])+)\\s*  # value\n            )*\n        )\\s*\n        (?P<fieldnames>  # Match a trailing set of field names\n            (?:\n                (?:\"(?:\\\\.|\"\"|[^\"])*\"|(?:\\\\.|[^\\s\"])+)\\s*\n            )*\n        )\\s*$\n        
\n        ^\\s*\n        define\\s+\n        (?P<name>\\S+\\b)\n        \\s+\n        =\n        
\n        ^1..(?P<expected>\\d+) # Match the plan details.\n        [^#]*                 # Consume any non-hash character to confirm only\n                              # directives appear with the plan details.\n        \\#?                   # Optional directive marker.\n        \\s*                   # Optional whitespace.\n        (?P<directive>.*)     # Optional directive text.\n    
\n        ^Bail\\ out!\n        \\s*            # Optional whitespace.\n        (?P<reason>.*) # Optional reason.\n    
\n        ^Bearer\\s{1}(       # starts with Bearer and a single space\n        [a-zA-Z0-9\\-\\_]+\\.  # 1 or more chars followed by a single period\n        [a-zA-Z0-9\\-\\_]+\\.  # 1 or more chars followed by a single period\n        [a-zA-Z0-9\\-\\_]*    # 0 or more chars, no trailing chars\n        )$\n      
\n        ^Full[ ]Tilt[ ]Poker[ ]                                 # Poker Room\n        Game[ ]\\#(?P<ident>\\d*):[ ]                             # Hand history id\n        (?P<tournament_name>                                    # Tournament name\n            \\$?(?P<buyin>\\d*)?                                  # buyin, not always there,\n                                                                # part of tournament_name\n        .*)[ ]                                                  # end of tournament_name\n        \\((?P<tournament_ident>\\d*)\\),[ ]                       # Tournament Number\n        Table[ ](?P<table_name>\\d*)[ ]-[ ]                      # Table name\n        (?P<limit>NL|PL|FL|No Limit|Pot Limit|Fix Limit)[ ]     # limit\n        (?P<game>.*?)[ ]-[ ]                                    # game\n        (?P<sb>\\d*)/(?P<bb>\\d*)[ ]-[ ].*                        # blinds\n        \\[(?P<date>.*)\\]$                                       # date in ET\n        
\n        { ( [^}]*  \\Q$Separator\\E  [^}]* ) }\n    
\n        <!DOCTYPE\n        \\s+(?P<name>[a-zA-Z_:][\\w:.-]*)\n        \\s+(?:\n            SYSTEM\\s+([\"'])(?P<system_id_a>.*?)\\2\n            |\n            PUBLIC\n            \\s+([\"'])(?P<public_id_b>.*?)\\4\n            # HTML 3.2 and 2.0 doctypes don't include a system-id.\n            (?:\\s+([\"'])(?P<system_id_b>.*?)\\6)?\n        )\n        (\\s*\\[.*?\\])?\n        \\s*>\n        
\n        Code:\\ (?P<code>\\d+),\n        \\ e\\.displayText\\(\\)\\ =\\ (?P<type1>[^ \\n]+):\\ (?P<msg>.+?),\n        \\ e.what\\(\\)\\ =\\ (?P<type2>[^ \\n]+)\n    
\n        http(s)?://(www\\.)?huajiao.com\n        /l/(?P<channel>[^/]+)\n
\n        http://www.dingit.tv/(\n            highlight/(?P<highlight_id>\\d+)|\n            channel/(?P<broadcaster>\\w+)/(?P<channel_id>\\d+)\n    )
\n        https?://(?:www\\.)?\n        (?:\n            tv4play.se/program/[^\\?/]+\n            |\n            fotbollskanalen.se/video\n        )\n        /(?P<video_id>\\d+)\n    
\n        https?://\n        (?P<base_url>\n            (?:(?:\n                iptv\\.glattvision|www\\.(?:myvisiontv|saktv|vtxtv)\n            )\\.ch\n            )|(?:(?:\n                mobiltv\\.quickline|www\\.quantum-tv|zattoo\n            )\\.com\n            )|(?:(?:\n                tvonline\\.ewe|nettv\\.netcologne|tvplus\\.m-net\n            )\\.de\n            )|(?:(?:\n                player\\.waly|www\\.netplus\n            )\\.tv)\n            |www\\.bbv-tv\\.net\n            |www\\.meinewelt\\.cc\n        )/\n        (?:\n            (?:ondemand/)?(?:watch/(?:[^/\\s]+)(?:/[^/]+/(?P<recording_id>\\d+)))\n            |\n            watch/(?P<channel>[^/\\s]+)\n            |\n            ondemand/watch/(?P<vod_id>[^-]+)-\n        )\n        
\n        https?://\n        (\n            www.mycanal.fr/(.*)/(.*)/p/(?P<video_id>[0-9]+)\n        )\n
\n        https?://www\\.bloomberg\\.com/(\n            news/videos/[^/]+/[^/]+ |\n            (?P<channel>live/(?:stream|emea|asia_stream|europe|us|asia)|audio)/?\n        )\n
\n        System\\simage\\sfile\\sis\\s       (?# Start from System image line)\n        \"[^:/]*(?::/|:)                 (?# Match from \" and * until :/)\n        (?P<sw_image>[^\"]*)             (?# Capture everything until end \")\n        .*?^(?P<hostname>\\S*)           (?# .* Until capture hostname)\n        \\sup\\s                          (?# Match up)\n        (?P<uptime>[^\\r\\n]*)            (?# Capture uptime)\n        .*?^Hardware:\\s+?               (?# Match until Hardware:   )\n        (?P<model>\\S*),                 (?# Capture hardwmare model)\n        .*?^Serial\\sNumber:\\s           (?# Match up to Serial Number)\n        (?P<serial_no>\\S*)\\s            (?# Capture the serial number)\n        
\n        url\\(          # Start with the literal url(\n        ('|\"|)         # Then either a single, double or no quote at all\n        (\n          ([^'\")]+)    # The file basename, and below the extension\n          \\.(
\n        v?\n        (?:\n            (?:(?P<epoch>[0-9]+)!)?                           # epoch\n            (?P<release>[0-9]+(?:\\.[0-9]+)*)                  # release segment\n            (?P<pre>                                          # pre-release\n                [-_\\.]?\n                (?P<pre_l>(a|b|c|rc|alpha|beta|pre|preview))\n                [-_\\.]?\n                (?P<pre_n>[0-9]+)?\n            )?\n            (?P<post>                                         # post release\n                (?:-(?P<post_n1>[0-9]+))\n                |\n                (?:\n                    [-_\\.]?\n                    (?P<post_l>post|rev|r)\n                    [-_\\.]?\n                    (?P<post_n2>[0-9]+)?\n                )\n            )?\n            (?P<dev>                                          # dev release\n                [-_\\.]?\n                (?P<dev_l>dev)\n                [-_\\.]?\n                (?P<dev_n>[0-9]+)?\n            )?\n        )\n        (?:\\+(?P<local>[a-z0-9]+(?:[-_\\.][a-z0-9]+)*))?       # local version\n    
\n      # \"haml-lint:\" with optional spacing\n      \\s*haml-lint\\s*:\\s*\n\n      # The mode - either disable or enable\n      (?<mode>(?:dis|en)able)\\b\\s*\n\n      # \"all\" or a comma-separated list (with optional spaces) of linters\n      (?<linters>all | (?:
\n      # optional number, gerund - adjective -participle\n      (?:
\n      #PID TTY          TIME CMD      \n      #1 ?        00:00:00 init\n      (?P<pid>\\d{1,6})\\s*(?P<tty>[\\d\\w\\?\\/]+)\\s*(?P<time>[\\d\\:]+)\\s*(?P<name>[\\d\\w\\/\\<\\>\\s]+)   \n
\n      &\n      (?:\n        \\w+\n      |\n        \\#\n        (?:\n          \\d+\n        |\n          x
\n      ( \n        # Match substrings that end in whitespace shorter than limit\n        
\n      (?:
\n      (?: '.+?(?<!\\\\)'\n        | \".+?(?<!\\\\)\"\n      )\n    
\n      (?: \\$\\{ | \\{\\$ ) [^}]++ \\}\n      |\n      \\$\\$?[a-zA-Z_]\\w*\n      
\n      (?: \\/\\* (?> (?:.|\\n)*? \\*\\/ ) ) |\n      (?: \\/\\/ .*(?:\\\\\\n.*)*(?:\\z|(?<!\\\\)\\n) )\n    
\n      (?: M-|C-|c )\n      (?: \\\\ (?: M-|C-|c ) )*\n      (?: [^\\\\] | \\\\ 
\n      (?:\\\\[\\\\bfnrt\"/])   # Escaped control characters, \" and /\n      |(?:\\\\U00\\h{6})     # 6 byte escaped Unicode\n      |(?:\\\\u\\h{4})       # 4 byte escaped Unicode\n    
\n      (?:\n        (?:\\band\\b\\s+)?\n        \\bend\n        (?: 
\n      (?:\n        \\\\(.)                  # grab escaped characters (including $)\n      |\n        (?:\n          \\$\\{([1-9]\\d*)\\}   # match \"${1}\" (not unrelated '${0}')\n        |\n          \\$  ([1-9]\\d*)     # match  \"$1\"  (not unrelated '$0')\n        )\n      )\n    
\n      (?:^|[\\s+\\-/*()]) # math or space separated, or beginning of string\n      ( # capture whole length\n        0 # unitless zero\n        |\n        [-+]? # optional sign\n        (?:\n          \\.\\d+ # with leading decimal, e.g. .5\n          |\n          \\d+(\\.\\d+)? # whole or maybe with trailing decimal\n        )\n        (?:
\n      (?<comment_indicator>^\\+\\s*[^a-z0-9\\+\\s]+)\n      (\\n\\+)?\\s+\n      (?<todo_indicator>
\n      (?<escape>\\\\?)\n      \\$\n      (\n        {(?<name>[a-zA-Z0-9_]+)}\n      |\n        \\g<name>\n      )\n    
\n      (?<family>
\n      (?<piece>          [BKNQR]      ){0}\n      (?<destination>    [a-h][1-8]   ){0}\n      (?<promotion>      =[BNQR]      ){0}\n      (?<check>          [#+]         ){0}\n      (?<capture>        x            ){0}\n      (?<disambiguation> [a-h]?[1-8]? ){0}\n\n      (?<castle>         O-O(-O)?     ){0}\n\n      (?<normal>\n        \\g<piece>?\n        \\g<disambiguation>\n        \\g<capture>?\n        \\g<destination>\n        \\g<promotion>?\n      ){0}\n\n      \\A (\\g<castle> | \\g<normal>) \\g<check>? \\z\n    
\n      (?<range>
\n      (?>[ \\t\\f\\v]+)\n      (?:\n        [%\\/][^\\s=]\n      | <<-?\\S\n      | [-+] \\d\n      | 
\n      (\n        (
\n      (\n        (-)?                  # Minus\n        (?:(\\w+):)?           # Field\n        (?:\n          (?:\"(.*?)(?<!\\\\)\")  # Quoted query\n          |\n          ([^\\s]+)            # Single query\n        )\n      )\n    
\n      '(\n        \\\\['\\\\\\/bfnrt] |\n        \\\\u[0-9a-fA-F]{4} |\n        [^'\\\\\\b\\f\\n\\r\\t]\n      )*'\n    
\n      /(\n        \\\\[\\/bfnrt] |\n        \\\\u[0-9a-fA-F]{4} |\n        [^/\\b\\f\\n\\r\\t]\n      )*/[imxouesn]*\n    
\n      :\n      (?:\n        
\n      \"(\n        \\\\[\"\\\\\\/bfnrt] |\n        \\\\u[0-9a-fA-F]{4} |\n        [^\"\\\\\\b\\f\\n\\r\\t]\n      )*\"\n    
\n      \\( \\s*      # coordinate 1\n         (\\d+\\.?\\d*) \\s* # x1 number\n         ,\\s*            # whitespace after comma is ok\n         (\\d+\\.?\\d*) \\s* # y1 number\n      \\)\n      \\s*        # space between coordinates is ok\n      \\( \\s*      # coordinate 2\n         (\\d+\\.?\\d*) \\s* # x2 number\n         ,\\s*            # whitespace after comma is ok\n         (\\d+\\.?\\d*) \\s* # y2 number\n      \\)\n      (
\n      \\( \\s*      # coordinate 1\n        (\\d+\\.?\\d*) \\s* # x1 number\n        ,\\s*            # whitespace after comma is ok\n        (\\d+\\.?\\d*) \\s* # y1 number\n        ,\\s*            # whitespace after comma is ok\n        (\\d+\\.?\\d*) \\s* # r1 number\n      \\)\n      \\s*         # space between coordinates is ok\n      \\( \\s*      # coordinate 2\n        (\\d+\\.?\\d*) \\s* # x2 number\n        ,\\s*            # whitespace after comma is ok\n        (\\d+\\.?\\d*) \\s* # y2 number\n        ,\\s*            # whitespace after comma is ok\n        (\\d+\\.?\\d*) \\s* # r2 number\n      \\)\n      (
\n      \\?\n      (?:\n        [^\\s\\\\]\n      | \\\\ 
\n      \\+\\+JvmOptions=\"\n        -Djruby.home=C:\\\\Program\\ Files\\\\jruby;\n        -Djruby.lib=C:\\\\Program\\ Files\\\\jruby\\\\lib;\n        -Djruby.script=jruby;\n        -Djruby.daemon.module.name=Trinidad;\n        -Djruby.compat.version=RUBY1_9\n      \"\n    
\n      \\A (\n        (?m:\\s*) (\n          (\\/\\* (?m:.*?) \\*\\/) |\n          (\\#\\#\\# (?m:.*?) \\#\\#\\#) |\n          (\\/\\/ .* \\n?)+ |\n          (\\# .* \\n?)+ |\n          (
\n      \\A\n      [\"'](.*)[\"']    # Extract text between quotes\n      \\s*\\)?\\s*;?\\s*  # Sometimes the Sass parser includes a trailing ) or ;\n      (//.*)?         # Exclude any trailing comments that might have snuck in\n      \\z\n    
\n      \\A\n      [^[:cntrl:][@\\[\\]\\^ \\!\"\\#$\\(\\)*,/:;<=>?`{|}~\\\\]]+                        # mailbox\n      @\n      (?:[^[:cntrl:][@\\[\\]\\^ \\!\\\"\\#$&\\(\\)*,/:;<=>\\?`{|}~\\\\_.%+']]+\\.)+         # subdomains\n      (?:[^[:cntrl:][@\\[\\]\\^ \\!\\\"\\#$&\\(\\)*,/:;<=>\\?`{|}~\\\\_.%+\\-'0-9]]{2,25})  # TLD\n      \\z\n    
\n      \\A\n      foo_bar /\n      \\h{8}    # 8 hex chars\n      (?: - \\h{4} ){3}  # 3 groups of 4 hex chars (hyphen sep)\n      - \\h{12}  # 12 hex chars (hyphen sep again)\n      \\Z\n    
\n      \\A\n      https?://                                                    # http:// or https://\n      ([^\\s:@]+:[^\\s:@]*@)?                                        # optional username:pw@\n      ( (([^\\W_]+\\.)*xn--)?[^\\W_]+([-.][^\\W_]+)*\\.[a-z]{2,6}\\.? |  # domain (including Punycode/IDN)...\n          
\n      \\b                    # start at word boundary\n      (                     # begin $1  
\n      \\b (?: 
\n      \\e \\[ ( 
\n      \\Q$fulltag\\E\n    
\n      ^ ( 
\n      ^(
\n      ^(\\s* \\$ \\s (CURL_BIN | 
\n      ^\n         (?:\n             # first skip all \"normal\" text (not <)\n             [^<]+\n           | # then skip CDATA sections\n             <\\[CDATA\\[ (?: [^\\]]+ | \\][^\\]] | \\]\\][^>] )* \\]\\]>\n           | # now process processing instructions\n             <\\? (\\w+) \\s+ ( (?: [^?] | \\?[^>] )+ )* \\?\\>\n                (?{\n                   push @pi, [$-[1] - 2, $+[2] + 2, $1, $2] if exists $_[1]{$1};\n                })\n           | # else must be a tag\n             <[^?]\n         )*\n      $\n   
\n      ^\n      (?:\\s*[-+*]|(?:\\d+\\.))? # optional list prefix\n      \\s*                     # optional whitespace prefix\n      (                       # checkbox\n        
\n      ^\n      (\n        
\n      ^--\\Q$boundary\\E             \\015?\\012\n      ((?:[^\\015\\012]+\\015\\012)* ) \\015?\\012\n      (.*?)                        \\015?\\012\n      (--\\Q$boundary\\E (--)?       \\015?\\012)\n      
\n      `[^`]*? # The opening backtick on a plugin path\n      ([[[:alnum:]]_+-]+?) # The plugin name\n      (- ([[:xdigit:]]+ | 
\n      <meta\n          \\s+\n          name=['\"]go-import['\"]\n          \\s+\n          content=['\"](?P<root>[^\\s]+)\\s+(?P<vcs>[^\\s]+)\\s+(?P<url>[^\\s]+)['\"]\n          \\s*\n      /?>
\n      every\n        |\n      each\n        |\n      (?: 
\n      start\n      (?: 
\n     (
\n     (?:
\n     (?:\\G|\n      [^\\\\c-]|\n      (?:\\G|[^\\\\])(?:c|[CM]-)|\n      (?:\\G|[^CM])-\n     )\n     (?:\\\\(?:c|[CM]-)?){2}*\n   
\n     ^ \\s*                                      # ignore initial whitespaces\n     (?:\n      (?: [$] (?P<bound> [_a-z] [0-9a-z_]*? ))  # match new bounded field name\n      \\s*\n      (?:\n       (?:   / (?P<re_bound> .* )     / )     | # but limit values by regular expression\n       (?: - / (?P<re_bound_neg> .* ) / )       # but limit values by negation of regular expression\n      )?                                      |\n      (?:   / (?P<re> .* )     / )            | # limit values by regex\n      (?: - / (?P<re_neg> .* ) / )            | # limit values by regex\n      (?: [!] (?P<type> [_a-z] [0-9a-z_]*? )) | # limit values to instance of a type\n      (?: \\' (?P<literal> .*? [^ \\'] ) \\' )   | # only equals to this string literal\n      (?P<normal> [^  \\' $ !] .* )            | # only equals to this string literal\n     )\n     \\s* $                                      # ignore ending whitespaces\n     
\n     ^(?:alias|
\n     for(?:each)?+ \\b\n     (?>(?&PerlOWS))\n     (?:\n         (?:\n             my\n             (?>(?&PerlOWS)) ((?&PerlVariableScalar))\n         )?+\n         (?>(?&PerlOWS))\n         (?> ((?&PerlParenthesesList)) )\n         (?>(?&PerlOWS))\n         {\n      )\n      $grammar\n    
\n    # Colons introduce pseudo-selectors, sometimes with parens\n    # TODO doesn't handle quoted )\n    [:]+ [-\\w]+ (?: [(] .+? [)] )?\n\n    # These guys are combinators -- note that a single space counts too\n    | \\s* [ +>~,] \\s*\n\n    # Square brackets are attribute tests\n    # TODO: this doesn't handle ] within a string\n    | [[] .+? []]\n\n    # Dot and pound start class/id selectors.  Percent starts a Sass\n    # extend-target faux selector.\n    | [.#%] [-\\w]+\n\n    # Percentages are used for @keyframes\n    | [-.\\d]+ [%]\n\n    # Plain identifiers, or single asterisks, are element names\n    | [-\\w]+\n    | [*]\n\n    # & is the sass replacement token\n    | [&]\n\n    # And as a last-ditch effort, just eat up to whitespace\n    | (\\S+)\n
\n    # Define recurring patterns\n    (?<part> [\\w\\d-]+ ){0}\n\n    (?<user>\\g<part>)/(?<repo>\\g<part>).git$\n  
\n    # Grab the traceback header.  Different versions of Python have\n    # said different things on the first traceback line.\n    ^(?P<hdr> Traceback\\ \\(\n        (?: most\\ recent\\ call\\ last\n        |   innermost\\ last\n        ) \\) :\n    )\n    \\s* $                # toss trailing whitespace on the header.\n    (?P<stack> .*?)      # don't blink: absorb stuff until...\n    ^ (?P<msg> \\w+ .*)   #     a line *starts* with alphanum.\n    
\n    # Required components.\n    (?P<year>\\d{4} ) \\D?\n    (?P<month>\\d{2}) \\D?\n    (?P<day>\\d{2}  ) \\D?\n    (?:\n        # Optional components.\n        (?P<hour>\\d{2}  ) \\D?\n        (?P<minute>\\d{2}) \\D?\n        (?P<second>\\d{2})?\n    )?\n
\n    # Source consists of a PS1 line followed by zero or more PS2 lines.\n    (?P<source>\n        (?:^(?P<indent> [ ]*) >>>    .*)    # PS1 line\n        (?:\\n           [ ]*  \\.\\.\\. .*)*)  # PS2 lines\n    \\n?\n    # Want consists of any non-blank lines that do not start with PS1.\n    (?P<want> (?:(?![ ]*$)    # Not a blank line\n                 (?![ ]*>>>)  # Not a line starting with PS1\n                 .+$\\n?       # But any other line\n              )*)\n    
\n    # Text needs to be stripped and all extra spaces replaced by single spaces\n    (?P<name>^[A-Z0-9][A-Z0-9._-]*)?\n    \\s?\n    (\\[(?P<extras>.*)\\])?\n    \\s?\n    (?P<constraints>\\(? \\s? ([\\w\\d<>=!~,\\s\\.\\*]*) \\s? \\)? )?\n    \\s?\n
\n    %\n    \\((?P<mapping_key>[^)]+)\\)\n    (?P<conversion_type>[diouxXeEfFgGcrs%])\n    
\n    (
\n    ( \\\\U........      # 8-digit hex escapes\n    | \\\\u....          # 4-digit hex escapes\n    | \\\\x..            # 2-digit hex escapes\n    | \\\\[0-7]{1,3}     # Octal escapes\n    | \\\\N\\{[^}]+\\}     # Unicode characters by name\n    | \\\\[\\\\'\"abfnrtv]  # Single-character escapes\n    )
\n    ( \\\\U........\n    | \\\\u....\n    | \\\\x..\n    | \\\\[0-7]{1,3}\n    | \\\\N\\{[^}]+\\}\n    | \\\\[\\\\'\"abfnrtv]\n    )
\n    ( \\\\x..            # 2-digit hex escapes\n    | \\\\[\\\\'\"abfnrtv]  # Single-character escapes\n    )
\n    ( \\\\x..            # 2-digit hex escapes\n    | \\\\[0-7]{1,3}     # Octal escapes\n    | \\\\[\\\\'\"abfnrtv]  # Single-character escapes\n    )
\n    ((?:$RE
\n    ((?:\n        [^\\s'\"]*\n        (?:\n            (?:\"(?:[^\"\\\\]|\\\\.)*\" | '(?:[^'\\\\]|\\\\.)*')\n            [^\\s'\"]*\n        )+\n    ) | \\S+)\n
\n    ((?P<name>\\w+)\\s*=\\s*)?\n    (?P<value>\n        True|False|\n        \\d+.\\d+|\n        \\d+.|\n        \\d+|\n        [\\w\\d_.]+|\n        [urUR]?(?P<stringval>\"[^\"]*?\"|'[^']*')\n    )\\s*,\n
\n    ((?P<name>\\w+)\\s*=\\s*)?\n    (?P<value>\n        True|False|\n        \\d+.\\d+|\n        \\d+.|\n        \\d+|\n        \\w+|\n        [urUR]?(?P<stringval>\"[^\"]*?\"|'[^']*')\n    )\\s*,\n
\n    ((\\(?[Dd][Oo][Ii](\\s)*\\)?:?(\\s)*)       # 'doi:' or 'doi' or '(doi)' (upper or lower case)\n    |(https?://(dx\\.)?doi\\.org\\/))?         # or 'http://(dx.)doi.org/'  (neither has to be present)\n    (?P<doi>10\\.                            # 10.                        (mandatory for DOI's)\n    \\d{4}                                   # [0-9] x4\n    (/|%2f)                                 # / (possibly urlencoded)\n    [\\w\\-_:;\\(\\)/\\.<>]+                     # any character\n    [\\w\\-_:;\\(\\)/<>])                       # any character excluding a full stop\n    
\n    (?:\\(|\\,) # either a ( to start the definition or a , for next\n    \\s*       # maybe some whitespace\n    (\\w+)     # the col name\n    [^,]*     # anything but the end or a ',' for next column\n    PRIMARY\\sKEY
\n    (?:\n        (?P<converter>[a-zA-Z_][a-zA-Z0-9_]*)   # converter name\n        (?:\\((?P<args>.*?)\\))?                  # converter parameters\n        \\:                                      # variable delimiter\n    )?\n    (?P<variable>[a-zA-Z_][a-zA-Z0-9_]*)        # variable name\n
\n    (?:\n        \\[ \\[\n            (?P<desc0> [^\\]]+)\n        \\] \\]\n    ) |\n    (?:\n        \\[ \\[\n            (?P<link1> [^\\]]+)\n        \\] \\[\n            (?P<desc1> [^\\]]+)\n        \\] \\]\n    )\n    
\n    (?:\n      (?:(?P<hours>\\d+):)?\n      (?P<minutes>\\d+):\n    )?\n    (?P<seconds>\\d+)\n    
\n    (?<!\\$)\\$([a-zA-Z]+) # identifier\n    (:                   # initial widget value\n\n        (?: # grouping to avoid : to be treated as part of\n            # the left or operand\n\n            \"( # quoted string\n                (?:\n                    [^\"]|    # any character except \" or ...\n                    (?<=\\\\)\" # ... \" preceded by a backslash\n                )*\n            )\"|\n\n            ([a-zA-Z]+) # identifiers can be used instead of strings\n        )\n    )?|\n    (\\$\\$) # escaped $\n
\n    (?<!\\?)     #if no preceding escape (?)\n    '           #apostrophe\n    (?![\n\r])  #if no following CR of LF\n    
\n    (?<algorithm_number>\\d+)\\s*\n    (?<fingerprint_type>\\d+)\\s*\n    (?<fingerprint>
\n    (?<algorithm>\\d+)\\s*\n    (?<flags>\\d+)\\s*\n    (?<iterations>\\d+)\\s*\n    (?<salt>\\S+)\\s*\n    (?<next_hashed_owner_name>\\S+)\\s*\n    (?<rrset_types>
\n    (?<brace>\n    {\n    (\n    [^{}]\n    | \\g<brace>\n    )*\n    }\n    )\n    
\n    (?<comment>  /[*] [^*]* [*]+ (?: [^*/] [^*]* [*]+ )* /         ){0}\n    (?<keyword>  typedef | extern | static | auto | register |\n                 struct  | union  | enum                           ){0}\n    (?<C>        (?: \\g<block> | [^{}]+ )*                         ){0}\n    (?<block>    \\{ \\g<ws>* ^ \\g<C> $ \\g<ws>* \\}                   ){0}\n    (?<ws>       \\g<comment> | \\s                                  ){0}\n    (?<ident>    [_a-zA-Z] [0-9_a-zA-Z]*                           ){0}\n    (?<type>     (?: \\g<keyword> \\g<ws>+ )* \\g<ident>              ){0}\n    (?<arg>      \\g<type> \\g<ws>+ \\g<ident> | \\.\\.\\.               ){0}\n    (?<argv>     (?# empty ) |\n                 void        |\n                 \\g<arg> (?: \\g<ws>* , \\g<ws>* \\g<arg> \\g<ws>* )*  ){0}\n    (?<pragma>   \\g<ws>* // \\s* attr \\g<ws>+\n                 (?<pragma:type> \\g<type>   )              \\g<ws>+\n                 (?<pragma:name> \\g<ident>  )              \\g<ws>*\n                 =                                         \\g<ws>*\n                 (?<pragma:expr> .+?;       )              \\g<ws>* ){0}\n    (?<insn>     DEFINE_INSN                               \\g<ws>+\n                 (?<insn:name>   \\g<ident>  )              \\g<ws>*\n     [(] \\g<ws>* (?<insn:opes>   \\g<argv>   ) \\g<ws>* [)]  \\g<ws>*\n     [(] \\g<ws>* (?<insn:pops>   \\g<argv>   ) \\g<ws>* [)]  \\g<ws>*\n     [(] \\g<ws>* (?<insn:rets>   \\g<argv>   ) \\g<ws>* [)]  \\g<ws>* ){0}\n
\n    (?<comment> \\# .+? \\n                      ){0}\n    (?<ws>      \\g<comment> | \\s               ){0}\n    (?<insn>    \\w+                            ){0}\n    (?<paren>   \\( (?: \\g<paren> | [^()]+)* \\) ){0}\n    (?<expr>    (?: \\g<paren> | [^(),\\ \\n] )+  ){0}\n    (?<remain>  \\g<expr>                       ){0}\n    (?<arg>     \\g<expr>                       ){0}\n    (?<extra>   , \\g<ws>* \\g<remain>           ){0}\n    (?<args>    \\g<arg> \\g<extra>*             ){0}\n    (?<decl>    \\g<insn> \\g<ws>+ \\g<args> \\n   ){0}\n
\n    (?<cpu>(?:
\n    (?<flags>\\d+)\\s*\n    (?<protocol>\\d+)\\s*\n    (?<algorithm>\\d+)\\s*\n    (?<key>
\n    (?<key_tag>\\d+)\\s*\n    (?<algorithm>\\d+)\\s*\n    (?<digest_type>\\d+)\\s*\n    (?<digest>
\n    (?<nameserver>
\n    (?<next_domain>
\n    (?<order>\\d+)\\s*\n    (?<pref>\\d+)\\s*\n    (?<flags>
\n    (?<priority>\\d+)\\s*\n    (?<exchange>
\n    (?<priority>\\d+)\\s*\n    (?<weight>\\d+)\\s*\n    (?<port>\\d+)\\s*\n    (?<target>
\n    (?<type_covered>\\S+)\\s*\n    (?<algorithm>\\d+)\\s*\n    (?<labels>\\d+)\\s*\n    (?<original_ttl>
\n    (?<type> (recipe|role)) {0}   # The runlist item type.\n    (?<name> (.*)) {0}            # The runlist item name.\n\n    \\g<type>\\[\\g<name>\\]\n  
\n    (?<ws>      \\u0020 ){0}\n    (?<key>     \\w+    ){0}\n    (?<value>   0|1    ){0}\n    (?<define>  \\G \\#define \\g<ws>+ OPT_\\g<key> \\g<ws>+ \\g<value> \\g<ws>*\\n )\n
\n    (?P<address>[a-fA-F0-9x]+)  # match the hexadecimal address\n    :\\s                         # skip ': '\n    (?P<function>.+?)           # match the function's name, non-greedy\n    (?:                         # don't capture fname/line group\n        \\s\n        \\(\n        (?:in\\s)?               # skip 'in ' if present\n        (?P<fname>[^:]+)        # match the file name\n        :?                      # skip ':', if present\n        (?P<line>\\d+)?          # match the line number, if present\n        \\)\n    )?                          # fname/line group is optional\n    $                           # should have reached the EOL\n
\n    (?P<anomer>[abxo])?\n    (?P<conf_stem>(?:-[dlx][a-z]+)+)?-?\n    (?P<superclass>[A-Z]+)-?\n    (?P<indices>[0-9x]+:[0-9x]+)\n    (?P<modifications>(\\|[0-9x,]+:[0-9a-z]+)+)?\n    
\n    (?P<attr>\n        [\\w_-]+\n    )\n    (?P<sign>\n        \\+?=\n    )\n    (?P<value>\n    ['\"]? # start quote\n        [^\"']*\n    ['\"]? # end quote\n    )\n
\n    (?P<before> {% \\s*\n        url \\s+ )\n        (?P<name> \\S+ )\n        (?P<attrs> \\s+ .*? )\n    (?P<after> \\s* %} )\n
\n    (?P<COMMENT>\\#.*$)            # comment (until end of line)\n    |(?P<WORD>(object|class|counts|origin|delta|type|counts|rank|items|data))\n    |\"(?P<QUOTEDSTRING>[^\\\"]*)\"   # string in double quotes  (quotes removed)\n    |(?P<WHITESPACE>\\s+)          # white space\n    |(?P<REAL>[-+]?               # true real number (decimal point or\n    (\\d+(\\.\\d*)?|\\.\\d+)           # scientific notation) and integers\n    ([eE][-+]?\\d+)?)\n    |(?P<BARESTRING>[a-zA-Z_][^\\s\\#\\\"]+) # unquoted strings, starting with non-numeric\n    
\n    (?P<created_at>\n        (?P<year>[1-9]\\d{3})\n        (?:\n            [-_](?P<month>\\d{2})\n            (?:\n                [-_](?P<day>\\d{2})\n            )?\n        )?\n    )[-_]\n    (?P<name>.*)
\n    (?P<fence>^(?:~{3,}|`{3,}))[ ]*  # Opening ``` or ~~~\n    (\\{?\\.?(?P<lang>[\\w#.+-]*))?[ ]*    # Optional {, and lang\n    # Optional highlight lines, single- or double-quote-delimited\n    (hl_lines=(?P<quot>\"|')(?P<hl_lines>.*?)(?P=quot))?[ ]*\n    # Optional tab label, single- or double-quote-delimited\n    (fct_label=(?P<fct_quot>\"|')(?P<fct_label>.*?)(?P=fct_quot))?[ ]*\n    }?[ ]*\\n                                # Optional closing }\n    (?P<code>.*?)(?<=\\n)\n    (?P=fence)[ ]*$
\n    (?P<group_id>\n        [a-z0-9]{8}-(?:[a-z0-9]{4}-){3}[a-z0-9]{12}\n        ~\n        (?P<files_qty>\\d+)\n    )\n
\n    (?P<hour>\\d{1,2})    # one or two hour digits\n    :                    # :\n    (?P<minute>\\d{1,2})  # one or two minute digits\n    :                    # :\n    (?P<second>          # second decimal consisting of:\n        \\d{1,2}          #   two digits\n        (?:              #   then optionally\n            \\.           #     a dot\n            \\d*          #     and any number of digits\n        )\n    )\n    \\Z                   # end\n
\n    (?P<chrom>.+):\n    (?P<start>\\d+)-\n    (?P<stop>\\d+)\n    (?:\\[(?P<strand>.)\\])?
\n    (?P<key>[^=;]+)\n    (?:\\s*=\\s*\n        (?P<val>\n            \"(?:[^\\\\\"]|\\\\.)*\" |\n             (?:.*?)\n        )\n    )?\n    \\s*;\n
\n    (?P<kwargs>(?:\\s\\b[a-z_]+=\\w+\\s?)+)?\\Z # kwargs match everything at the end in groups \" name=arg\"\n    
\n    (?P<link>https?://[^ \\(\\)]+) # URL itself\n    \\s*                  # optional space\n    (?:\\((?P<title>[^)]+)\\))?       # optional text (in)\n
\n    (?P<macro>%[xXtTmM])\n    \\[\n    \\s*(?P<offset>[-]?\\d+)\\s*\n    ,\n    \\s*(?P<column>[^\\],\\s]+)\\s*  # identifier: anything but closing bracket or comma\n    (?P<rest>[\\],])              # closing bracket or comma\n    
\n    (?P<name>.+?)-(?P<ver>.+?)\n    (-(?P<pyver>py\\d\\.\\d)\n     (-(?P<arch>.+?))?\n    )?.egg$
\n    (?P<name>[^-]+) (\n        -(?P<ver>[^-]+) (\n            -py(?P<pyver>[^-]+) (\n                -(?P<plat>.+)\n            )?\n        )?\n    )?\n    
\n    (?P<name>[a-z] [^_]{0,3})\n    (?: _ \\$ (?P<symmetry>\\d+) )?\n    (?: _ (?P<resnum>\\d+))?\n    (?: _ (?P<plusminus>[\\+\\-]))?\n    |\n    \\$ (?P<element>[a-z]{1,2})\n    |\n    (?P<range> > | <)\n    
\n    (?P<name>[A-z-]+) # A option name, valid characters are A to z and dash.\n    \\s*\n    (?P<op>=)? # Separating the option and the value with a equals sign is\n               # common, but optional.\n    \\s*\n    (?P<value>.*) # The value, anything goes.\n
\n    (?P<name>[a-z_]+)       # Must start with a lowercase + underscores name\n    (?::(?P<variant>\\w+))?  # Variant is optional, \":variant\"\n    (?:(?P<args>[^\\Z]+))? # args is everything up to the end\n    
\n    (?P<no_fraction>\n        \\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}  # YYYY-MM-DDTHH:MM:SS\n    )\n    (                                        # Optional decimal part\n     \\.                                      # decimal point\n     (?P<nanos>\\d{1,9})                      # nanoseconds, maybe truncated\n    )?\n    Z                                        # Zulu\n
\n    (?P<outer_indentation>\\x20*)\n    \\.\\. \\x20 guide::\\n\n    (?:(?:(?P=outer_indentation) [^\\n]+\\n)|\\n)*
\n    (?P<parent_atom_replaced>[odhnx])\n    \\((?P<parent_attachment_position>-?[0-9\\-\\|]+)[\\+\\-]\n        (?P<child_attachment_position>-?[0-9\\-\\|]+)\\)\n    (?P<child_atom_replaced>[odhnx])\n    
\n    (?P<robot>.{4})         # robot name\n    [/ ][0-9][.][0-9].*     # trailing version\n    
\n    (?P<sequence> [^>^*]*? )\n    \\*?\\s*\\n(?:\\n|\\Z)\n    
\n    (?P<size>\\d+(\\.\\d+)?)\n    (?P<modifier>[Kk]|[Mm])?\n    (?:[Bb])?\n
\n    (?P<static>[^<]*)                           # static rule data\n    <\n    (?:\n        (?P<converter>[a-zA-Z_][a-zA-Z0-9_]*)   # converter name\n        (?:\\((?P<args>.*?)\\))?                  # converter arguments\n        \\:                                      # variable delimiter\n    )?\n    (?P<variable>[a-zA-Z_][a-zA-Z0-9_]*)        # variable name\n    >\n
\n    (?P<stream_url>(?:[\\w\\/\\.\\-:]+)\n    \\/[^_\\\"]+(?:_(?P<stream_quality_name>\\d+))\n    ?/playlist.m3u8)\n
\n    (?P<symop>[^\\s\\(\\)]+)\n     |\n    (?P<space>\\s+)\n     |\n    (?P<lpar>\\()\n     |\n    (?P<rpar>\\))\n    
\n    (?P<tag>%\\w+(\\:\\w+)?)?\n    (?P<id>\\#[\\w-]*)?\n    (?P<class>\\.[\\w\\.-]*)*\n    (?P<attributes>\\{.*\\})?\n    (?P<nuke_outer_whitespace>\\>)?\n    (?P<nuke_inner_whitespace>\\<)?\n    (?P<selfclose>/)?\n    (?P<django>=)?\n    (?P<inline>[^\\w\\.#\\{].*)?\n    
\n    (?P<text>[^\\s\\(\\)]+)\n     |\n    (?P<space>\\s+)\n     |\n    (?P<parens>[\\(\\)])\n    
\n    (?P<ymd>\n     \\d{4}-      # year\n     \\d{2}-      # month\n     \\d{2})      # day\n    T            # separator\n    (?P<hms>\n     \\d{2}:      # hour\n     \\d{2}:      # minute\n     \\d{2})      # second\n     
\n    ([^\\s].*)\n    (?:[\\s\\.]+(?:(?P<open_bracket>\\()\\s*[Ss][Ee][Rr]\\.)?\n            ([A-H]|(I{1,3}V?|VI{0,3}))\n    )?\n    (?(open_bracket)\\s*\\))$   ## Only match the ending bracket if the opening bracket was found
\n    (\\\\)?               # is it escaped with a backslash?\n    (\\$)                # literal $\n    (                   # collect braces with var for sub\n        \\{?             #   allow brace wrapping\n        ([A-Z0-9_]+)    #   match the variable\n        \\}?             #   closing brace\n    )                   # braces end\n
\n    (\n      \\d+                           # A few numbers\n      \\s+\n      (?:[A-Za-z'.-]+\\s?){1,5}      # Followed by a street name\n    )\n    \\s* ,?  \\s*                     # a comma, optionally\n    (\n      (?:\\d+\\s+)?                   # a secondary unit, optionally\n      (?:
\n    (\\s*Author:\\s+(?P<author>.*)\\s*)?                      # Author\n    (\\s*Maintainer:\\s+(?P<maintainer>.+)\\s*)?              # Maintainer\n    (\\s*Project-URL:\\sFunding,\\s+(?P<funding_url>.+)\\s*)?  # Funding URL\n
\n    (document\\.    # global javascript\n     | var\\s+      # local javascript\n     | <\\w+\\s+[^>]*?) # input, form, select, textarea tag\n      \\Q$key\\E   # the key\n      \\s*=\\s*    # an equals sign\n      ([\\\"\\'])   # open quote\n      (.+?[^\\\\]) # something in between\n      \\2        # close quote\n    
\n    (http(s)?://)?\n    (www\\.)?\n    huomao\n    (\\.tv|\\.com)\n    /(?P<room_id>\\d+)\n
\n    ;\\s*\n    (?P<key>\n        \"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"  # quoted string\n    |\n        [^\\s;,=*]+  # token\n    )\n    \\s*\n    (?:  # optionally followed by =value\n        (?:  # equals sign, possibly with encoding\n            \\*\\s*=\\s*  # * indicates extended notation\n            (?P<encoding>[^\\s]+?)\n            '(?P<language>[^\\s]*?)'\n        |\n            =\\s*  # basic notation\n        )\n        (?P<value>\n            \"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"  # quoted string\n        |\n            [^;,]+  # token\n        )?\n    )?\n    \\s*\n
\n    @(?P<status>[+-]?)(?P<field>\\w+|\\*)\\s+(?P<term>[^@()]+)\n    |\n    (?P<all>[^@()]+)
\n    @(param|return|throws)\n    \\h+\n    ((\\?<!\\$)[a-zA-Z0-9_\\]+)\n    \\h+\n    $[a-zA-Z0-9_]+\n    \\s*\\v
\n    [ \\t]*\n    [^\\s#\\\\]    # if we match, m.end()-1 is the interesting char\n
\n    [^[\\](){}#'\"\\\\]+\n
\n    \\\\ ( [\\n\\\\'\"abfnrtv]  |  # \\\\x single-character escapes\n         [0-7]{1,3}       |  # \\\\ooo octal escape\n         x[0-9A-Fa-f]{2}  |  # \\\\xXX hex escape\n         u[0-9A-Fa-f]{4}  |  # \\\\uXXXX hex escape\n         U[0-9A-Fa-f]{8}  |  # \\\\UXXXXXXXX hex escape\n         N\\{[- 0-9A-Z]+\\}    # \\\\N{name} Unicode name or alias\n       )\n    
\n    \"identity\" \\(\n      (?P<current>-?\\d+)\n      ,\\s\n      (?P<base>-?\\d+)\n      ,\\s\n      '(?P<seed>-?\\d+),(?P<step>-?\\d+)'\n      .*\n    \\)\n
\n    \\(\\*-?\\ *variables\\ *\\*\\)    # Match (* variables *) or (*- variables *)\n    (                            # Match and capture the following:\n    (?:                          # Start of non-capturing group, used to match a single character\n    (?!                          # only if it's impossible to match the following:\n    \\(\\*-?\\ *                    # - a literal (* or (*-\n    (?:                          # Inner non-capturing group, used for the following alternation:\n    variables                    # - Either match the word variables\n    |                            # or\n    endvariables                 # - the word endvariables\n    )                            # End of inner non-capturing group\n    \\ *-?\\*\\)                    # - a literal *) or -*)\n    )                            # End of negative lookahead assertion\n    .                            # Match any single character\n    )*                           # Repeat as often as possible\n    )                            # End of capturing group 1\n    \\(\\*\\ *endvariables\\ *-?\\*\\) # until (* endvariables *) or (* endvariables -*) is matched.\n    
\n    \\(\\?P<\n    (?P<name>\\w+)\n    >[^\\)]+\n    \\)
\n    \\[ ( [<\\|>\\^\\-\\_\\.\\,\\*\\d\\#\\$]* ) \\] ( [a-zA-Z]? )\n  
\n    \\A\n    (?<path> .+?)\n    (?:\n      [:]\n      (?<config> 
\n    \\\\A\n    ([
\n    \\A\n    (\n      
\n    \\A\n    https?://                                                    # http:// or https://\n    ([^\\s:@]+:[^\\s:@]*@)?                                        # optional username:pw@\n    ( (([^\\W_]+\\.)*xn--)?[^\\W_]+([-.][^\\W_]+)*\\..{2,}\\.? |       # domain (including Punycode/IDN)...\n        
\n    \\A\n    https?://                                                    # http:// or https://\n    ([^\\s:@]+:[^\\s:@]*@)?                                        # optional username:pw@\n    ( (([^\\W_]+\\.)*xn--)?[^\\W_]+([-.][^\\W_]+)*\\.[a-z]{2,6}\\.? |  # domain (including Punycode/IDN)...\n        
\n    \\A\\s*                      # optional whitespace at the start, then\n    (?P<sign>[-+]?)            # an optional sign, then\n    (?=\\d|\\.\\d)                # lookahead for digit or .digit\n    (?P<num>\\d*)               # numerator (possibly empty)\n    (?:                        # followed by an optional\n       /(?P<denom>\\d+)         # / and denominator\n    |                          # or\n       \\.(?P<decimal>\\d*)      # decimal point and fractional part\n    )?\n    \\s*\\Z                      # and optional whitespace to finish\n
\n    \\bc/o\\b\n    |\n    [(\"']*\\b[^\\s\\/,;#&()]+\\b[.,;:'\")]* # ['a-b. cd,ef- '] -> ['a-b.', 'cd,', 'ef']\n    |\n    [#&@/]\n    
\n    \\s*\\#\\s+                   # Lines that start with a '#'\n    (?P<hash_type>sha256):\\s+  # Hash type is hardcoded to be sha256 for now.\n    (?P<hash>[^\\s]+)           # Hashes can be anything except '#' or spaces.\n    \\s*                        # Suck up whitespace before the comment or\n                               #   just trailing whitespace if there is no\n                               #   comment. Also strip trailing newlines.\n    (?:\\#(?P<comment>.*))?     # Comments can be anything after a whitespace+#\n                               #   and are optional.\n    $
\n    \\s*\n    (\n        (?P<edifact>\n            (?P<UNA>\n                U[\n\r]*N[\n\r]*A\n                (?P<UNAstring>.+?)\n            )?\n            (?P<UNB>\n                U[\n\r]*N[\n\r]*B\n            )\n            [\n\r]*\n            (?P<field_sep>[^\n\r])\n        )\n        |\n        (?P<tradacoms>\n            (?P<STX>\n                S[\n\r]*T[\n\r]*X\n                [\n\r]*\n                =\n            )\n        )\n        |\n        (?P<x12>\n            I[\n\r]*S[\n\r]*A\n        )\n    )\n    
\n    \\s*\n    Previous\\ Balance\n    \\s+\n    \\$(?P<previous_balance>[\\d,]+\\.\\d\\d)\n    \\s+\n    New\\ Balance\n    \\s+\n    \\$(?P<new_balance>[\\d,]+\\.\\d\\d)$\n    
\n    \\s*n                    # skip zero or more spaces, then 'n'\n    (?P<num_children>\\d+)   # match number of children, 1 or more digits\n    :\\s                     # skip ':' and one space\n    (?P<num_bytes>\\d+)      # match the number of bytes, 1 or more digits\n    \\s                      # skip one space\n    (?P<details>.*)         # match the details\n
\n    \\s*v?\n    (?:\n        (?:(?P<epoch>[0-9]+)!)?                           # epoch\n        (?P<release>[0-9]+(?:\\.[0-9]+)*)                  # release segment\n        (?P<pre>                                          # pre-release\n            [-_\\.]?\n            (?P<pre_l>(a|b|c|rc|alpha|beta|pre|preview))\n            [-_\\.]?\n            (?P<pre_n>[0-9]+)?\n        )?\n        (?P<post>                                         # post release\n            (?:-(?P<post_n1>[0-9]+))\n            |\n            (?:\n                [-_\\.]?\n                (?P<post_l>post|rev|r)\n                [-_\\.]?\n                (?P<post_n2>[0-9]+)?\n            )\n        )?\n        (?P<dev>                                          # dev release\n            [-_\\.]?\n            (?P<dev_l>dev)\n            [-_\\.]?\n            (?P<dev_n>[0-9]+)?\n        )?\n    )\n    (?:\\+(?P<local>[a-z0-9]+(?:[-_\\.][a-z0-9]+)*))?       # local version\n\\s*$
\n    \\x{09C7}$is_Combining+[\\x{09BE}\\x{09D7}]\t\t| # BENGALI VOWEL SIGN E\n    \\x{0B47}$is_Combining+[\\x{0B3E}\\x{0B56}\\x{0B57}]\t| # ORIYA VOWEL SIGN E\n    \\x{0BC6}$is_Combining+[\\x{0BBE}\\x{0BD7}]\t\t| # TAMIL VOWEL SIGN E\n    \\x{0BC7}$is_Combining+\\x{0BBE}\t\t\t| # TAMIL VOWEL SIGN EE\n    \\x{0B92}$is_Combining+\\x{0BD7}\t\t\t| # TAMIL LETTER O\n    \\x{0CC6}$is_Combining+[\\x{0CC2}\\x{0CD5}\\x{0CD6}]\t| # KANNADA VOWEL SIGN E\n    [\\x{0CBF}\\x{0CCA}]$is_Combining\\x{0CD5}\t\t| # KANNADA VOWEL SIGN I or KANNADA VOWEL SIGN O\n    \\x{0D47}$is_Combining+\\x{0D3E}\t\t\t| # MALAYALAM VOWEL SIGN EE\n    \\x{0D46}$is_Combining+[\\x{0D3E}\\x{0D57}]\t\t| # MALAYALAM VOWEL SIGN E\n    \\x{1025}$is_Combining+\\x{102E}\t\t\t| # MYANMAR LETTER U\n    \\x{0DD9}$is_Combining+[\\x{0DCF}\\x{0DDF}]\t\t| # SINHALA VOWEL SIGN KOMBUVA\n    [\\x{1100}-\\x{1112}]$is_Combining[\\x{1161}-\\x{1175} ] | # HANGUL CHOSEONG KIYEOK..HIEUH\n    ($is_HangulLV|[\\x{1100}-\\x{1112}][\\x{1161}-\\x{1175}])($is_Combining)([\\x{11A8}-\\x{11C2}]) # HANGUL SyllableType=LV\n  
\n    ^   # Beginning of line.\n    (((?P<first_page>\\w+)\\,)?(?P<per_page>\\w+)\\s+)?  # First page, per page.\n    (?P<objects>[\\.\\w]+)  # Objects / queryset.\n    (\\s+starting\\s+from\\s+page\\s+(?P<number>[\\-]?\\d+|\\w+))?  # Page start.\n    (\\s+using\\s+(?P<key>[\\\"\\'\\-\\w]+))?  # Querystring key.\n    (\\s+with\\s+(?P<override_path>[\\\"\\'\\/\\w]+))?  # Override path.\n    (\\s+as\\s+(?P<var_name>\\w+))?  # Context variable name.\n    $   # End of line.\n
\n    ^   # Beginning of line.\n    (starting\\s+from\\s+page\\s+(?P<number>\\w+))?\\s*  # Page start.\n    (using\\s+(?P<key>[\\\"\\'\\-\\w]+))?\\s*  # Querystring key.\n    (as\\s+(?P<var_name>\\w+))?  # Context variable name.\n    $   # End of line.\n
\n    ^ ( (?P<username> [^@]+ ) @ )? # optional username\n    (?P<hostname> [^:]+ ) :        # mandatory host name\n    (?P<directory> .* )            # optional pathname\n
\n    ^ ( (?P<username> [^@]+ ) @ )? # optional username\n    (?P<hostname> [^:]+ ) ::       # mandatory host name\n    (?P<module> [^/]+ )            # mandatory module name\n    ( / (?P<directory> .* ) )? $   # optional pathname (without leading slash)\n
\n    ^ > [ \\t\\v\\f]*\n    (?P<name> [^\\n]* ) \\n\n    (?P<sequence> [^>^*]* )\n    \\*?\\s*\n    
\n    ^ > [ \\t]*\n    (?P<name> [^\\s^:]+ ) [ :]? [ \\t]*\n    (?P<description> [^\\n]* ) \\n\n    (?P<sequence> [^>]* )\n    \\s*\n    
\n    ^ > \\s* PDB \\s* :\n    (?P<name> [^_]+ ) _\n    (?P<chain> \\w* ) \\s* \\n\n    (?P<sequence> [^>]* )\n    \\s*\n    
\n    ^ > \\s*\n    (?P<names> [^\\n]* ) \\n\n    (?P<alignments> [^>^*]* )\n    \\*?\\s*\n    
\n    ^ >\n    (?P<name> [^\\n]* ) \\n\n    (?P<description> [^\\n]* ) \\n\n    (?P<sequence> [^>^\\*]* )\n    \\*? \\s*\n    
\n    ^ >\n    (?P<names> \\S+ ) \\s+\n    (?P<descriptions> [^\\n]* ) \\n\n    (?P<alignments> [^>]* )\n    \\s*\n    
\n    ^ >\n    (?P<type> [PFDRN][13LC] ) ;\n    (?P<name> \\S* ) \\n\n    (?P<description> [^\\n]* ) \\n\n    (?P<sequence> [^>^\\*]* )\n    \\* \\s*\n    
\n    ^ >\n    (?P<types> [PFDRN][13LC] ) ;\n    (?P<names> \\S+ ) \\n\n    (?P<descriptions> [^\\n]* ) \\n\n    (?P<alignments> [^>]* )\n    \\* \\s*\n    
\n    ^ rsync://                    # static prefix\n    ( (?P<username>[^@]+) @ )?    # optional username\n    (?P<hostname> [^:/]+ )        # mandatory host name\n    ( : (?P<port_number> \\d+ ) )? # optional port number\n    / (?P<module> [^/]+ )         # mandatory module name\n    ( / (?P<directory> .* ) )? $  # optional pathname (without leading slash)\n
\n    ^(?:\n        (?P<host>[^:]+)               # ipv4 address or host name\n        |\\[(?P<host6>[a-zA-Z0-9:]+)\\] # ipv6 address in square brackets\n    )                                 # end of host part\n    (?::(?P<port>\\d+))?$              # optional port part\n    
\n    ^(?P<date>\\S+)\n    \\s+\n    (?P<time>\\S+)\n    \\s+\n    \\S+\n    \\s+\n    \\S+\n    \\s+\n    (?P<message>.*)\n    $\n    
\n    ^(?P<package>.+)-\n    (?P<version>\\d[^-]*)[-\\.]\n    ((?P<platform>[^-]*)-)?\n    (?P<python_version>[^-]+)\n    .(?P<format>(exe|msi))\n    (\\#md5=.*)?\n    $\n
\n    ^(?P<package>.+)-\n    (?P<version>\\d[^-]*)\n    (-(?P<platform>[^\\.]+))?\n    .(?P<format>tar.(gz|bz2)|zip)\n    (\\#md5=.*)?\n    $\n
\n    ^(?P<package>.+)-\n    (?P<version>\\d[^-]*)-\n    (?P<python_version>[^-]+)\n    (-(?P<platform>[^\\.]+))?\n    .(?P<format>egg)\n    (\\#md5=.*)?\n    $\n
\n    ^(?P<package>.+)-\n    (?P<version>\\d[^-]*)-\n    (?P<python_version>[^-]+)-\n    (?P<abi>[^-]+)-\n    (?P<platform>.+)\n    .(?P<format>whl)\n    (\\#md5=.*)?\n    $\n
\n    ^(?P<repo>git.*|.*\\.git)?$\n    
\n    ^(bb:|bitbucket:|https?://(www\\.)?bitbucket.org/)\n    (?P<repo>[^@]*)(@(?P<revision>.*))?$\n    
\n    ^(gh:|github:|https?://(www\\.)?github.com/)\n    (?P<repo>[^@]*)(@(?P<revision>.*))?$\n    
\n    ^(gh:|github:|https?://(www\\.)?github.com/|git@github.com:)\n    (?P<repo>[^@]*)(@(?P<revision>.*))?$\n    
\n    ^(git:|https)?://git.launchpad.net/\n    (?P<repo>[^@]*)(@(?P<revision>.*))?$\n    
\n    ^(lp:|launchpad:|https?://((code|www)\\.)?launchpad.net/)\n    (?P<repo>[^@]*)(@(?P<revision>.*))?$\n    
\n    ^(lp:|launchpad:|https?://((code|www)\\.)?launchpad.net/|bzr\\+ssh://[^/]+/)\n    (?P<repo>[^@]*)(@(?P<revision>.*))?$\n    
\n    ^-?(?:(?P<hours>\\d+):)?(?P<minutes>\\d+):(?P<seconds>\\d+)$\n
\n    ^\n    (//)?                  # preceding double-slash($1)\n    (?:\\[([\\h:]+)\\]|([^\\s:/]+)) # IPv6 enclosed by square brackets($2) or hostname($3)\n    (?::(\\d+))?            # port($4)\n    (?:\n      /\n      ([^\\s:/]+)?          # service name($5)\n      (?::([^\\s:/]+))?     # server($6)\n      (?:/([^\\s:/]+))?     # instance name($7)\n    )?\n    $\n  
\n    ^\n    (:(?P<prefix>[^\\s]+)\\s+)?    # Optional prefix (src, nick!host, etc)\n                                 # Prefix matches all non-space characters\n                                 # Must start with a \":\" character\n\n    (?P<command>[^:\\s]+)         # Command is required (JOIN, 001, 403)\n                                 # Command matches all non-space characters\n\n    (?P<params>(\\s+[^:][^\\s]*)*) # Optional params after command\n                                 # Must have at least one leading space\n                                 # Params end at first \":\" which starts message\n\n    (?:\\s+:(?P<message>.*))?     # Optional message starts after first \":\"\n                                 # Must have at least one leading space\n    $\n    
\n    ^\n    (?:\n        (?P<module_path>\n            (?:    [^\\d\\W] \\w* )\n            (?: \\. [^\\d\\W] \\w* )*\n        )\n        :\n    )?\n    (?P<call>\n        (?P<function> [^\\d\\W] \\w* )\n        \\( .*? \\)\n    )\n    $\n
\n    ^\n    (?:\n        (?P<title>[^<]+)\n        \\s*\n        <\n        (?P<issue1>\\d+)\n        >\n    |\n        (?P<issue2>\\d+)\n    )\n    $\n    
\n    ^\n    (?P<major>(?:0|[1-9][0-9]*))\n    \\.\n    (?P<minor>(?:0|[1-9][0-9]*))\n    \\.\n    (?P<patch>(?:0|[1-9][0-9]*))\n    (\\-(?P<prerelease>\n        (?:0|[1-9A-Za-z-][0-9A-Za-z-]*)\n        (\\.(?:0|[1-9A-Za-z-][0-9A-Za-z-]*))*\n    ))?\n    (\\+(?P<build>\n        [0-9A-Za-z-]+\n        (\\.[0-9A-Za-z-]+)*\n    ))?\n    $\n    
\n    ^\n    (?P<modified>.*(AM|PM))\n    \\s*\n    (?P<size>(<DIR>|\\d*))\n    \\s*\n    (?P<name>.*)\n    $\n    
\n    ^\n    (?P<module>\n        [a-z_][a-z0-9_]*(?:\\.[a-z_][a-z0-9_]*)*\n    )\n    :\n    (?P<object>\n        [a-z_][a-z0-9_]*(?:\\.[a-z_][a-z0-9_]*)*\n    )\n    $\n    
\n    ^\n    (?P<version>\\d+\\.\\d+)          # minimum 'N.N'\n    (?P<extraversion>(?:\\.\\d+)*)   # any number of extra '.N' segments\n    (?:\n        (?P<prerel>[abc]|rc)       # 'a'=alpha, 'b'=beta, 'c'=release candidate\n                                   # 'rc'= alias for release candidate\n        (?P<prerelversion>\\d+(?:\\.\\d+)*)\n    )?\n    (?P<postdev>(\\.post(?P<post>\\d+))?(\\.dev(?P<dev>\\d+))?)?\n    $
\n    ^<pre> \\s* $\n    (?P<pre_block>\n        (\\n|.)*?\n    )\n    ^</pre> \\s* $\n    [\\s\\n]*\n
\n    ^0+(?P<order>[1-9]\\d*)\n    [-_]\n    (?P<name>.*)\n
\n    ^bundle:(?P<entity>.*)$\n    
\n    ^cs:(?P<entity>.*)$\n    
\n    <\n    (?:\n        (?P<type>int|str|float)   # the type of variable\n        \\:\n    )?\n    (?P<variable>[a-zA-Z][a-zA-Z0-9_]*)         # the name of variable\n    >\n
\n    <pre>\n    (?P<pre_inline>\n        (\\n|.)*?\n    )\n    </pre>\n
\n    ARXIV[\\s:-]*(?P<year>(1[3-9]|[2-8][0-9]))-?(?P<month>(0[1-9]|1[0-2]))\n    [\\s.-]*(?P<num>\\d{5})(?!\\d)(?:[\\s-]*V(?P<version>\\d))?\n    \\s*(?P<suffix>\\[[A-Z.-]+\\])? 
\n    ARXIV[\\s:-]*(?P<year>\\d{2})-?(?P<month>\\d{2})\n    [\\s.-]*(?P<num>\\d{3})\n    \\s*\\[(?P<suffix>[A-Z.-]+)\\]
\n    ARXIV[\\s:-]*(?P<year>\\d{2})-?(?P<month>\\d{2})\n    [\\s.-]*(?P<num>\\d{4})(?!\\d)(?:[\\s-]*V(?P<version>\\d))?\n    \\s*(?P<suffix>\\[[A-Z.-]+\\])? 
\n    http(s)?://(\\w+\\.)?\n    (?P<domain>vaughnlive|breakers|instagib|vapers|pearltime).tv\n    (/embed/video)?\n    /(?P<channel>[^/&?]+)\n
\n    http(s)?://(\\w+\\.)?\n    dailymotion.com\n    (?:\n        (/embed)?/(video|live)\n        /(?P<media_id>[^_?/]+)\n    |\n        /(?P<channel_name>[A-Za-z0-9-_]+)\n    )\n
\n    http(s)?://(\\w+\\.)?crunchyroll\\.\n    (?:\n        com|de|es|fr|co.jp\n    )\n    (?:/[^/&?]+)?\n    /[^/&?]+-(?P<media_id>\\d+)\n
\n    http(s)?://(\\w+\\.)?cybergame.tv\n    (?:\n        /videos/(?P<video_id>\\d+)\n    )?\n    (?:\n        /(?P<channel>[^/&?]+)\n    )?\n
\n    http(s)?://(www\\.)?(hitbox|smashcast).tv\n    /(?P<channel>[^/]+)\n    (?:\n        (?:/videos)?/(?P<media_id>[^/]+)\n    )?\n
\n    http(s)?://(www\\.)?dr.dk\n    (?:\n        /[TtVv]+/\n        (?:\n            live/(?P<channel>[^/]+)\n        )?\n        (?:\n            se/(.+/)?(?P<program>[^/&?]+)\n        )?\n    )\n
\n    http(s)?://(www\\.)?zhanqi.tv\n    /(?P<channel>[^/]+)\n
\n    http(s)?://\n    (?:\n        (?P<subdomain>.+)\n        \\.\n    )?\n    douyu.com/\n    (?:\n        show/(?P<vid>[^/&?]+)|\n        (?P<channel>[^/&?]+)\n    )\n
\n    http(s)?://\n    (?:\n        (?P<subdomain>[\\w\\-]+)\n        \\.\n    )?\n    twitch.tv/\n    (?:\n        videos/(?P<videos_id>\\d+)|\n        (?P<channel>[^/]+)\n    )\n    (?:\n        /\n        (?P<video_type>[bcv])(?:ideo)?\n        /\n        (?P<video_id>\\d+)\n    )?\n    (?:\n        /\n        (?P<clip_name>[\\w]+)\n    )?\n
\n    http(s)?://live.bilibili.com\n    /(?P<channel>[^/]+)\n
\n    https://www\\.kingkong\\.com\\.tw/\n    (?:\n        video/(?P<vid>[0-9]+G[0-9A-Za-z]+)|\n        (?P<channel>[0-9]+)\n    )\n
\n    https?://(?:\\w+\\.)?arte\\.tv/(?:guide/)?\n    (?P<language>[a-z]{2})/\n    (?:\n        (?:videos/)?(?P<video_id>(?!RC\\-|videos)[^/]+?)/.+ | # VOD\n        (?:direct|live)        # Live TV\n    )\n
\n    index=\n    (?P<table_name>`[^`]+`)\n    \\ # space\n    (?P<rule>USE|IGNORE|FORCE)\n    \\ # space\n    (\n        FOR\n        \\ # space\n        (?P<for_what>JOIN|ORDER\\ BY|GROUP\\ BY)\n        \\ # space\n    )?\n    (?P<index_names>(`[^`]+`(,`[^`]+`)*)|NONE)\n    
\n    No \\s ( \\d+) \\s* (?: \\n | \\r\\n | \\r )\n    > \\s* ( [^\\n]* ) (?: \\n | \\r\\n | \\r )\n    Probab = ( [+-]? \\d+ \\. \\d* ) \\s+\n    E-value = ( \\d+ \\.? \\d* )( e[+-]? \\d+ )? \\s+\n    Score = ( \\d+\\.\\d+ ) \\s+\n    (?: Aligned_cols | Aligned_columns ) = ( \\d+ ) \\s+\n    Identities = ( \\d+ ) %\n    [^\\n]*\n    (?: \\n | \\r\\n | \\r )\n    (?P<blocks> .*? )(?= (?:^No) | (?:\\Z) )\n    
\n    No \\s ( \\d+) \\s* (?: \\n | \\r\\n | \\r )\n    >( [\\w]{4} ) _  ( [\\w]? ) \\s ( [^\\n]* )(?: \\n | \\r\\n | \\r )\n    Probab = ( [+-]? \\d+ \\. \\d* ) \\s+\n    E-value = ( \\d+ \\.? \\d* )( e[+-]? \\d+ )? \\s+\n    Score = ( [+-]? \\d+\\.\\d+ ) \\s+\n    (?: Aligned_cols | Aligned_columns ) = ( \\d+ ) \\s+\n    Identities = ( \\d+ ) %\n    [^\\n]*\n    (?: \\n | \\r\\n | \\r )\n    (?P<blocks> .*? )(?= (?:^No) | (?:\\Z) )\n    
\\n    ts\\.sys =([^]*)\\n    \\}\\)\\(\\);
\n    type [
\n    typedef \\s+ enum \\s* \\{\n    (\n      (?:\n        \\s*\n        \\w+ \\s* = \\s* \\d+ \\s* ,\n      )+\n    )\n    \\s*\n    \\Q$count_tag\\E\n    \\s* \\} \\s* \\Q$name\\E \\s* ;\n  
\n    zrpc-conn:(?P<addr>\\d+.\\d+.\\d+.\\d+:\\d+)\\s+\n    calling\\s+\n    (?P<method>\n     \\w+)        # the method\n    \\(           # args open paren\n      \\'         # string quote start\n        (?P<tid>\n         \\S+)    # first argument -- usually the tid\n      \\'         # end of string\n    (?P<rest>\n     .*)         # rest of line\n    
\n  (?<!\\\\)(\n   (?:\\\\\\\\)*\n   (?:\n     [^\\w\\s\\\\$e]\n    |\n     \\\\\n     (?: [^\\W$e] | \\s | $ )\n   )\n  )\n 
\n  (?P<name>[a-zA-Z][\\w\\.]*)      # variable name: \"var\" or \"x\"\n  (\\[\\s*(?P<index>\\d+)\\s*\\])?  # (optional) index: \"1\" or None\n  \\s*=\\s*\n  ((?P<val>[^,\\[]*)            # single value: \"a\" or None\n   |\n   \\[(?P<vals>[^\\]]*)\\])       # list of values: None or \"1,2,3\"\n  ($|,\\s*)
\n  (?P<name>[a-zA-Z][\\w]*)      # variable name: \"var\" or \"x\"\n  (\\[\\s*(?P<index>\\d+)\\s*\\])?  # (optional) index: \"1\" or None\n  \\s*=\\s*\n  ((?P<val>[^,\\[]*)            # single value: \"a\" or None\n   |\n   \\[(?P<vals>[^\\]]*)\\])       # list of values: None or \"1,2,3\"\n  ($|,\\s*)
\n  (?P<year>\\d\\d\\d\\d)                # four digits year\n  (?:-?                             # one optional dash\n   (?:                              # followed by:\n    (?P<year_day>\\d\\d\\d             #  three digits year day\n     (?!\\d))                        #  when there is no fourth digit\n   |                                # or:\n    W                               #  one W\n    (?P<week>\\d\\d)                  #  two digits week\n    (?:-?                           #  one optional dash\n     (?P<week_day>\\d)               #  one digit week day\n    )?                              #  week day is optional\n   |                                # or:\n    (?P<month>\\d\\d)?                #  two digits month\n    (?:-?                           #  one optional dash\n     (?P<day>\\d\\d)?                 #  two digits day\n    )?                              #  after day is optional\n   )                                #\n  )?                                # after year is optional\n  (?:[T ]                           # one T or one whitespace\n   (?P<hour>\\d\\d)                   # two digits hour\n   (?::?                            # one optional colon\n    (?P<minute>\\d\\d)?               # two digits minute\n    (?::?                           # one optional colon\n     (?P<second>\\d\\d)?              # two digits second\n     (?:[.,]                        # one dot or one comma\n      (?P<fraction>\\d+)             # n digits fraction\n     )?                             # after second is optional\n    )?                              # after minute is optional\n   )?                               # after hour is optional\n   (?:                              # timezone:\n    (?P<Z>Z)                        #  one Z\n   |                                # or:\n    (?P<signal>[-+])                #  one plus or one minus as signal\n    (?P<hour_off>\\d                 #  one digit for hour offset...\n     (?:\\d(?!\\d$)                   #  ...or two, if not the last two digits\n    )?)                             #  second hour offset digit is optional\n    (?::?                           #  one optional colon\n     (?P<min_off>\\d\\d)              #  two digits minute offset\n    )?                              #  after hour offset is optional\n   )?                               # timezone is optional\n  )?                                # time is optional\n  (?P<garbage>.*)                   # store the extra garbage\n
\n  \\(\\s*\\$\\]\\s*>=\\s*5\\.005\\s*\\?\\s*(?:\\#\\#\\s*\\QAdd these new keywords supported since 5.005\\E\\s*)?\n  \\s+\\(\\s*ABSTRACT(?:_FROM)?\\s*=>\\s*'([^'\\n]+)',\\s*(?:\\#\\s*\\Qretrieve abstract from module\\E\\s*)?\n  \\s+AUTHOR\\s*=>\\s*'([^'\\n]+)'\n  \\s*\\)\\s*\\Q: ()\\E\\s*\\),\\s+\n  
\n  \\A(?:
\n  ^\n  (?P<name> .+? ) \\s+\n  (?P<alignment> [A-Z\\-]+ )\n  (?P<number> \\s+ \\d+ )? \\s* $\n  
\n  ^FOREIGN\\ KEY \\s* \\(   # FOREIGN KEY, arbitrary whitespace, literal '('\n    (?P<columns>         # Start a group to capture the referring columns\n      (?:                # Start a non-capturing group\n        \\s*              # Arbitrary whitespace\n        ([_a-zA-Z][\\w$]* | (\"[^\"]+\")+)   # SQL identifier\n        \\s*              # Arbitrary whitespace\n        ,?               # There will be a colon if this isn't the last one\n      )+                 # Close the non-capturing group; require at least one\n    )                    # Close the 'columns' group\n  \\s* \\)                 # Arbitrary whitespace and literal ')'\n  \\s* REFERENCES \\s*\n    ((?P<referred_schema>([_a-zA-Z][\\w$]* | (\"[^\"]*\")+))\\.)? # SQL identifier\n    (?P<referred_table>[_a-zA-Z][\\w$]* | (\"[^\"]*\")+)         # SQL identifier\n  \\s* \\(   # FOREIGN KEY, arbitrary whitespace, literal '('\n    (?P<referred_columns> # Start a group to capture the referring columns\n      (?:                # Start a non-capturing group\n        \\s*              # Arbitrary whitespace\n        ([_a-zA-Z][\\w$]* | (\"[^\"]+\")+)   # SQL identifier\n        \\s*              # Arbitrary whitespace\n        ,?               # There will be a colon if this isn't the last one\n      )+                 # Close the non-capturing group; require at least one\n    )                    # Close the 'columns' group\n  \\s* \\)                 # Arbitrary whitespace and literal ')'\n
\n  ^PRIMARY \\s* KEY \\s* \\(  # FOREIGN KEY, arbitrary whitespace, literal '('\n    (?P<columns>         # Start a group to capture column names\n      (?:\n        \\s*                # Arbitrary whitespace\n        # SQL identifier or delimited identifier\n        ( [_a-zA-Z][\\w$]* | (\"[^\"]*\")+ )\n        \\s*                # Arbitrary whitespace\n        ,?                 # There will be a colon if this isn't the last one\n      )+                  # Close the non-capturing group; require at least one\n    )\n  \\s* \\) \\s*                # Arbitrary whitespace and literal ')'\n
\n  =\\?                   # literal =?\n  (?P<charset>[^?]*?)   # non-greedy up to the next ? is the charset\n  \\?                    # literal ?\n  (?P<encoding>[qb])    # either a \"q\" or a \"b\", case insensitive\n  \\?                    # literal ?\n  (?P<encoded>.*?)      # non-greedy up to the next ?= is the encoded string\n  \\?=                   # literal ?=\n  
\n  =\\?                   # literal =?\n  (?P<charset>[^?]*?)   # non-greedy up to the next ? is the charset\n  \\?                    # literal ?\n  (?P<encoding>[qb])    # either a \"q\" or a \"b\", case insensitive\n  \\?                    # literal ?\n  (?P<atom>.*?)         # non-greedy up to the next ?= is the atom\n  \\?=                   # literal ?=\n  
\\\\N
\\n *(?P<c>\\x1B\\[\\d+m) *
\\\\n \\\\l
\n# Must start with a sequence of word-characters, followed by an equals sign\n(?P<attr_name>\\w+)=\n\n# Then either a quoted or unquoted attribute\n(?:\n\n # Match everything that\\'s between matching quote marks\n (?P<qopen>[\"\\'])(?P<q_val>.*?)(?P=qopen)\n|\n\n # If the value is not quoted, match up to whitespace\n (?P<unq_val>(?:[^\\s<>/]|/(?!>))+)\n)\n\n|\n\n(?P<end_link>[<>])\n
\\n$program\\_LDFLAGS\\s*=.*KDE_PLUGIN
\\n$program\\_LDFLAGS\\s*=.*-no-undefined
\\n$source\\_DIR\\s*=\\s*(\\S+)\\n
\\n$sourceprogram\\_SOURCES\\s*=\\s*(.*)\\n
\\n($realprogram)(\\$\\(EXEEXT\\)?)?:.*\\$\\($program\\_OBJECTS\\)
\n((^|\\ ) [\"'\\(\\[]*)           # begin of line or space and opt. any char \"'([\n([a-z][\\w+-.]*://[^\\s|]+?)   # url\n(?=[\\]\\)|\"'.,!?:;]* ($|\\ ))   # opt. any char ])\"'.,!?:; and end of line or space\n
\\n(?! {2}\\S)\\h*
\\\n(?# FLAG        )\\\\([^\\x80-\\xff(){ \\x00-\\x1f\\x7f%\"\\\\]+)|\\\n(?# ATOM        )([^\\x80-\\xff(){ \\x00-\\x1f\\x7f%*\"\\\\]+)
\n(?:\n    (?:(?P<hours>\\d+):)?\n    (?P<minutes>\\d+):\n)?\n(?P<seconds>\\d+)\n
\n(?:\n    \\|(?P<ket_c>[^\\|\\ {}<>]+)>\n)\n(?P<between>\\ *)\n(?:\n    <(?P<bra_c>[^\\|\\ <>]+)\\|\n)\n
\n(?<!(\\\\left|right))(?P<type>[()])\n
\n(?<![_\\^].)\n(?P<operator>[_\\^]) # ^ or _\n(?P<before> # optional whitespace before\n  \\ *?\n)\n(?P<content>\n  [a-zA-Z0-9]\n  [a-zA-Z0-9\\+\\*\\-]+\n)\n\n(?P<after>\n  $|\\ |\\n|\\|\n)\n
\\n(?=
\n(?P<before>^|\\ |\\n|\\(|\\{)\n(?P<bra>\n    <(?P<bra_c>[^\\|\\ {}<>]+)\\|\n)\n(?P<after>$|\\ |\\n|\\)|\\})\n
\n(?P<before>^|\\ |\\n|\\(|\\{)\n(?P<content>\n\\\\\\w+?|             #\\word.. b\n\\\\vec\\ \\w|          #\\vec p.. b\n\\\\vec\\{[^\\{\\}]+\\} #\\vec{abc}.. b. no nested {} because that's impossible in regex\n)\n\\.\\.\n(?=$|\\ |\\n|,|\\)|\\})\n
\n(?P<before>^|\\ |\\n|\\(|\\{)\n(?P<content>\n\\\\\\w+?|             #\\word.. b\n\\\\vec\\ \\w|          #\\vec p.. b\n\\\\vec\\{[^\\{\\}]+\\} #\\vec{abc}.. b. no nested {} because that's impossible in regex\n)\n\\.\n(?=$|\\ |\\n|,|\\)|\\})\n
\n(?P<before>^|\\ |\\n|\\(|\\{)\n(?P<content>\\w+?)\n\\.\\.\n(?=$|\\ |\\n|,|\\)|\\})\n
\n(?P<before>^|\\ |\\n|\\(|\\{)\n(?P<content>\\w+?)\n\\.\n(?=$|\\ |\\n|,|\\)|\\})\n
\n(?P<before>^|\\ |\\n|\\(|\\{)\n(?P<ket>\n    \\|(?P<ket_c>[^\\|\\ {}<>\\n]+)>\n)\n(?P<after>$|\\ |\\n|\\)|\\})\n
\n(?P<distance>[0-9]*)NM\\s+EITHER\\s+SIDE\\s+OF\\s+LINE\\s+\n
\n(?P<frac>\\\\frac)\n\\ +\n(?P<num>    # 2 or more chars\n  [^\\{\\n]   # don't start with {\n  [^\\ \\n]+\n)\n\\ +\n(?P<denom>  # denominator can be a single char\n  [^\\{\\n]\n  [^\\ \\n]*\n)\n
\\n(?P<indent1>\\s*)if (?P<cond1>[^\\n]+):\\n+\\1(?P<indent2>\\s+)(?P<comment>(?:\\#[^\\n]*\\n+\\1\\3)*)if (?P<cond2>[^\\n]+):\\n+(?P<block>\\1\\3(?P<indent3>\\s+)[^\\n]*\\n+(?:\\1\\3\\7[^\\n]*\\n+)*)(?!\\1(?:\\3|elif|else))
\n(?P<ip>\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\\s+\n-\\s+\n(?:(?P<user>\\w+)|-)\\s+\n\\[(?P<timestamp>\\d{2}\\/\\w{3}\\/\\d{4}:\\d{2}:\\d{2}:\\d{2})\\]\\s+\n\"(?:(?P<method>\\w+)\\s+(?P<uri>.+)\\s+HTTP\\/(?P<version>\\d\\.\\d)|-)\"\\s+\n(?:(?P<status>\\d+)|-)\\s+\n(?:(?P<bytes>\\d+)|-)\\s+\n\"(?:(?P<referrer>.*?)|-)\"\\s+\n\"(?P<user_agent>.*?)\"\n(?:\\s+(?:\nrequest_time_seconds=(?:(?P<request_time_secs>\\d+)|-)|\nrequest_time_microseconds=(?:(?P<request_time_usecs>\\d+)|-)|\nguru_id=(?:(?P<guru_id>\\w+)|-)|\n\\w+=.+?))*\n
\n(?P<modulename>\\w+(\\.\\w+)*)\n(:(?P<objectname>\\w+(\\.\\w+)*))?\n\\s*\n(\\[(?P<extras>.+)\\])?\n$\n
\n(?P<nm>[^-]+)\n-(?P<vn>\\d+[^-]*)\n(-(?P<bn>\\d+[^-]*))?$\n
\n(?P<nm>[^-]+)\n-(?P<vn>\\d+[^-]*)\n(-(?P<bn>\\d+[^-]*))?\n-(?P<py>\\w+\\d+(\\.\\w+\\d+)*)\n-(?P<bi>\\w+)\n-(?P<ar>\\w+(\\.\\w+)*)\n\\.whl$\n
\n(?P<nm>[^-]+)\n-(?P<vn>\\d+[^-]*)\n(-(?P<bn>\\d+[^-]*))?\n-(?P<py>\\w+\\d+(\\.\\w+\\d+)*)\n-(?P<bi>\\w+)\n-(?P<ar>\\w+)\n\\.whl$\n
\n(?P<object>.*?)                                       # Whatever was before it.\n\\.to(?:                                               # Get all the options of.\n    String|                                           # toString\n    Int|                                              # toInt\n    Float|                                            # toFloat\n    Bool|                                             # toBool\n    PyObject|                                         # toPyObject\n    Ascii                                             # toAscii\n)\\(.*?\\)(?P<end>.*)
\n(?P<offset>[0-9]+)?(?P<drct>N|NE|NNE|ENE|E|ESE|SE|SSE|S|SSW|SW|WSW|W|WNW|NW|NNW)?\\s?(?P<loc>[A-Z0-9]{3})\n
\n(?P<operator>[_\\^]) # ^ or _\n(?P<before> # optional whitespace before\n  \\ *?\n)\n(?P<content>\n  [^\\ \\{\\}\\n\\^\\_]{2,}\n)\n(?P<after>\\ )\n
\n(?P<payload>[^*]*\\*[A-F0-9][A-F0-9])\n(?P<uscg_metadata>\n(\n  (,S(?P<slot>\\d*))\n  | (,s(?P<rssi>\\d*))  # Receiver signal strength indicator.\n  | (,d(?P<signal_strength>[-0-9]*))  # dB.\n  | (,t(?P<receiver_time>(?P<hour>\\d\\d)(?P<minute>\\d\\d)  # UTC time.\n      (?P<second>\\d\\d.\\d*)))\n  | (,T(?P<time_of_arrival>[^,]*))  # Seconds within the minute.\n  | (,x(?P<counter>[0-9]*))\n  | (,(?P<station>(?P<station_type>[rRbBbD])[a-zA-Z0-9_-]*))\n)*\n,(?P<time>\\d+([.]\\d*)?)?  # Logger timestamp.  Can be hours from receive time.\n)\n
\n(?P<root>[\\w\\.]+)?\\.connect(?:\\s+)?\\((?:[\\s\\n]+)?\n\n# Making the owner optional. \n# _connect_repl has been updated to use root if owner is missing.\n(?:(?P<owner>.*?),(?:[\\s\\n]+)?)?   \n\n(?:QtCore\\.)?SIGNAL(?:\\s+)?(?:\\s+)?\\((?:[\\s\\n]+)?(?:_fromUtf8(?:\\s+)?\\()?(?:[\\s\\n]+)?[\\'\\\"](?P<signal>\\w+)(?:(?:\\s+)?\\((?P<signal_args>.*?)\\))?[\\'\\\"](?:[\\s\\n]+)?\\)?(?:[\\s\\n]+)?\\),(?:[\\s\\n]+)?\n\n  # Either QtCore.SLOT(\"thing()\") or an actual callable in scope.\n  # If it is the former, we are assuming that the str name is owned by root.\n    (?:(?:(?P<slot_owner>.*>?),(?:[\\s\\n]+)?)?(?:(?:QtCore\\.)?SLOT(?:\\s+)?\\((?:[\\s\\n]+)?(?:_fromUtf8(?:\\s+)?\\()?(?:[\\s\\n]+)?[\\'\\\"](?P<strslot>.*?)(?:\\s+)?\\((?P<slot_args>.*?)\\)[\\'\\\"](?:[\\s\\n]+)?\\)?(?:[\\s\\n]+)?\\))\n  |\n    (?:(?:[\\s\\n]+)?(?P<slot>.*?)(?:,)?(?:[\\s\\n]+)?))\n\\)
\n(?P<root>[\\w\\.]+)?\\.disconnect(?:\\s+)?\\((?:[\\s\\n]+)?\n(?P<owner>.*?),(?:[\\s\\n]+)?\n(?:QtCore\\.)?SIGNAL(?:\\s+)?\\((?:[\\s\\n]+)?(?:_fromUtf8(?:\\s+)?(?:\\s+)?\\()?(?:[\\s\\n]+)?[\\'\\\"](?P<signal>\\w+)(?:\\s+)?\\((?P<signal_args>.*?)(?:\\s+)?\\)[\\'\\\"](?:[\\s\\n]+)?\\)?(?:[\\s\\n]+)?\\),(?:[\\s\\n]+)?\n\n  # Either QtCore.SLOT(\"thing()\") or an actual callable in scope.\n  # If it is the former, we are assuming that the str name is owned by root.\n    (?:(?:(?P<slot_owner>.*>?),(?:[\\s\\n]+)?)?(?:(?:QtCore\\.)?SLOT(?:\\s+)?\\((?:[\\s\\n]+)?(?:_fromUtf8(?:\\s+)?\\()?(?:[\\s\\n]+)?[\\'\\\"](?P<strslot>.*?)(?:\\s+)?\\((?P<slot_args>.*?)(?:\\s+)?\\)[\\'\\\"](?:[\\s\\n]+)?\\)?(?:[\\s\\n]+)?\\))\n  |\n    (?:(?:[\\s\\n]+)?(?P<slot>.*?)(?:,)?(?:[\\s\\n]+)?))\n(?:\\s+)?\\)
\n(?P<root>[\\w\\.]+)?\\.emit(?:\\s+)?\\((?:[\\s\\n]+)?\n(?:(?P<owner>.*?),(?:[\\s\\n]+)?)?\n(?:QtCore\\.)?SIGNAL(?:\\s+)?(?:\\s+)?\\((?:[\\s\\n]+)?(?:_fromUtf8(?:\\s+)?\\()?(?:[\\s\\n]+)?[\\'\\\"](?P<signal>\\w+)(?:(?:\\s+)?\\((?P<signal_args>.*?)\\))?[\\'\\\"](?:[\\s\\n]+)?\\)?(?:[\\s\\n]+)?\\)\n\n  # Getting the args.\n(?:,(?:[\\s\\n]+)?(?:[\\s\\n]+)?(?P<args>.*)\n(?:\\s+)?)?(?:[\\s\\n]+)?(?:\\s+)?\\)
\n(?x)\n((((git|hg)\\+)?(git|ssh|https?):(//)?)  # something like git:// ssh:// etc.\n |                                      # or\n (\\w+@[\\w\\.]+)                          # something like user@...\n)\n
\n(\n  \"(?P<key> (\\\\ . | [^\"])* )\"       # Quoted key\n)\n[ ]* => [ ]*    # Pair operator, optional adjoining whitespace\n(\n    (?P<value_null> NULL )          # NULL value\n  | \"(?P<value> (\\\\ . | [^\"])* )\"   # Quoted value\n)\n
\n(\n (?:                     # Start of non-capturing group\n  (?:\\r\\n|\\r|\\n)      |  # Match any single newline, or\n  [^\\r\\n'\"]+          |  # Match any character series without quotes or\n                         # newlines, or\n  \"(?:[^\"\\\\]|\\\\.)*\"   |  # Match double-quoted strings, or\n  '(?:[^'\\\\]|\\\\.)*'      # Match single quoted strings\n )\n)\n
\n(\n Cl? |             # Cl and Br are part of the organic subset\n Br? |\n [NOSPFIbcnosp*] |  # as are these single-letter elements\n \\[[^]]*\\]         # everything else must be in []s\n)\n
\n(\\\\\n(?P<metadata>(\n  (\n    c:(?P<time>\\d{10,15}(\\.\\d*)?) |  # Receiver Unix time in seconds or millisec\n    d:(?P<dest>[^*,\\\\]{1,15}) |  # Destination\n    g:(?P<group>(?P<sentence_num>\\d)-(?P<sentence_tot>\\d)-(?P<group_id>\\d+)) |\n    n:(?P<line_num>\\d+) |  # Line count\n    q:(?P<quality>\\w) |  # Orbcomm specific character code\n    r:(?P<rel_time>\\d+) | # Relative time\n    s:(?P<rcvr>[^$*,!\\\\]{1,15}) |  # Source / station\n    t:(?P<text>[^$*,!\\\\]+) |  # Text string\n    T:(?P<text_date>[^$*,!\\\\]+)  # Orbcomm human readable date\n  )[,]?\n)+([*](?P<tag_checksum>[0-9A-Fa-f]{2}))?)\n\\\\)(?P<payload>.*)\n
\\n(\\s{1,
\n(^\n\t\t\t\\[\n        (?P<section>\t.+) \\]\n        \t\t(\\s+((\\#|;).*)?)?\n$)|(^\n    \t\t\t\\s*\n        (?P<option>\t[^\\#;]+?)\n        \t\t(\\s* (=|:) \\s*)\n        (?P<value>\t.+?)?\n        \t\t(\\s+((\\#|;).*)?)?\n$)|(^\n\t\t       \t(\\s*(\\#|;)+\\s*\n        (?P<cmted>\t(.|\\s)*))\n$)|(^\n        \t\t\\s+\n        (?P<cont>\t[^\\#;]*?)\n        \t\t(\\s+(\\#|;).*)?\n$)
\n(^\n\t\t\t\\s*\n        (?P<option>\t[^\\#;]+?)\n        \t \t(\\s* (=|:) \\s*)\n        (?P<value>\t.+?)?\n        \t\t(\\s+((\\#|;).*)?)?\n$)|(^\n    \t\t\t(\\s*(\\#|;)+\\s*\n        (?P<cmted>\t(.|\\s)*))\n$)|(^\n\t\t\t\\s+\n        (?P<cont>\t[^\\#;]*?)\n    \t\t\t(\\s+(\\#|;).*)?\n$)
\n(rel\\s*=\\s*(?:\"(?P<rel1>[^\"]*)\"|'(?P<rel2>[^']*)'|(?P<rel3>[^>\\s\n]*))\\s+)?\nhref\\s*=\\s*(?:\"(?P<url1>[^\"]*)\"|'(?P<url2>[^']*)'|(?P<url3>[^>\\s\n]*))\n(\\s+rel\\s*=\\s*(?:\"(?P<rel4>[^\"]*)\"|'(?P<rel5>[^']*)'|(?P<rel6>[^>\\s\n]*)))?\n
\\n.*?merge yylloc info into a new yylloc instance[^]*?\\bthis\\.yyMergeLocationInfo\\b[^]*?\\};[^]*?\\n
\\n...\\n[^]*$
\\n@(?P<type>[a-z]+)
\\n[ \\t\\r\\n]*use\n                  [ \\t\\r\\n]+\n                  ([^ \\t\\r\\n;]+)\n                  [ \\t\\r\\n]+\n                  (qw[ \\t\\r\\n]*+.[ \\t\\r\\n]*+|['\"])\n                  ([^:!])\n                  [^;]*\n                  ['\" \\t\\r\\n][:!]\n                 
\n[ \t]*+(?!\n)
\n[ ]*\n  Nr\\. [ ]+ (?P<nr>\\d+) [ ]+\n  Spin [ ]+ (?P<spin>\\d+) [ ]+\n  K-Point [ ]+ (?P<a>\\S+) [ ]+ (?P<b>\\S+) [ ]+ (?P<c>\\S+) [ ]*\n  \\n\n[ ]* (?P<npoints>\\d+) [ ]* \\n\n(?P<values>\n  [\\s\\S]*?(?=\\n.*?[ ] Nr|$)  # match everything until next 'Nr.' or EOL\n)\n
\n[ ]*\n  POINT [ ]+ (?P<pointnr>\\d+) [ ]+ (?P<a>\\S+) [ ]+ (?P<b>\\S+) [ ]+ (?P<c>\\S+)\n
\n[ ]*\n  SET: [ ]* (?P<setnr>\\d+) [ ]*\n  TOTAL [ ] POINTS: [ ]* (?P<totalpoints>\\d+) [ ]*\n  \\n\n(?P<content>\n  [\\s\\S]*?(?=\\n.*?[ ] SET|$)  # match everything until next 'SET' or EOL\n)\n
\\n[\\\\](2)s*
\\n[^\\S\\n]*(
\\n[_a-z0-9]+ (tox_[\\_a-z]+\\()
\\n\\\\
\n\\ ->\\^\\{(?P<top>[^{}].*?)\\}\n
\n\"([^\"\\\\]|\\\\.)*\" |\n'([^'\\\\]|\\\\.)*'\n
\n\\$\\{                                   # opening brace for the lookup\n((?P<type>[._\\-a-zA-Z0-9]*(?=\\s))      # type of lookup, must be followed by a\n                                       # space\n?\\s*                                   # any number of spaces separating the\n                                       # type from the input\n(?P<input>[@\\+\\/,\\.\\?_\\-a-zA-Z0-9\\:\\s=\\[\\]\\*]+) # the input value to the lookup\n)\\}                                    # closing brace of the lookup\n
\\n\\?\\101\\x42\\u0043\\u{44 45}
\\\\N\\{(.*?)(?:\\}|$)
\\\\N\\{(?P<name>[^}]+)\\}
\\\\N\\{([A-Z ]+)\\}
\\\\N\\{[^}]*\\x{a0}[^}]*\\}
\\n\\+CME\\s+ERROR:\\s+(?P<error>[\\w ]+)
\\n\\1+
\n\\A\n(?:\n   (?P<scheme> [a-zA-Z] [^:]* )\n   (?P<colon_after_scheme> : )\n)?\n(?P<pathish> [^?#]* )\n(?:\n  (?P<question_mark> [?] )\n  (?P<query> [^#]* )\n)?\n(?:\n  (?P<hash_sign> [#] )\n  (?P<fragment> .* )\n)?\n\\Z\n
\n\\A\n(?:\n   (?P<username> [^:]* )\n   (\n     (?P<colon_before_password> : )\n     (?P<password> .* )\n   )?\n   (?P<at_sign> @ )\n)?\n(?P<host> \\[[^]]*\\] | [^:]* )\n(?:\n  (?P<colon_before_port> : )\n  (?P<port> .* )\n)?\n\\Z\n
\n\\A\n(?P<slashes> [/\\\\\\r\\n\\t]* )\n(?P<authority> [^/\\\\]* )\n(?P<path> [/\\\\] .* )?\n\\Z\n
\n\\A\n(?P<slashes> [\\r\\n\\t]* (?:/[\\r\\n\\t]*){2} )\n(?P<authority> [^/]* )\n(?P<path> / .* )?\n\\Z\n
\n\\A\n(?P<slashes> [\\r\\n\\t]* (?:[/\\\\][\\r\\n\\t]*){2} )\n(?P<host> [^/\\\\]* )\n(?P<path> [/\\\\] .* )?\n\\Z\n
\\n\\h+
\\n\\h+(?=\\n)
\\n\\h+(\\S+\\h+)? => \".*\"$
\n\n                \\?\n                (q?)                        # $1\n\n                (                           # $2\n                    sub \\s*\n                    (                       # $3\n                        \\s*\n\n                        \\{\n                            (               # $4\n                                (?: (?> 
\n\n        (?: ^ | [^\\\\] )     # Beginning of string or a character besides \"\\\"\n\n        \\{                  # \"{\"\n\n        
\n\n        (?: ^ | [^\\\\] )     # Beginning of string or a character besides \"\\\"\n\n        \\}                  # \"}\"\n\n        
\n\n        \\s *                                # Optional whitespace\n        (?P<option>                         # One or more chars excluding\n            [^:=\\s]                         # : a = characters (and first\n            [^:=] *                         # must not be whitespace)\n        )\n        \\s *                                # Optional whitespace\n        (?P<vi>\n            [:=]                            # Single = or : character\n        )\n        \\s *                                # Optional whitespace\n        (?P<value>\n            . *                             # One or more characters\n        )\n        $\n\n        
\n\n        \\s *                                # Optional whitespace\n        \\[                                  # Opening square brace\n\n        (?P<header>                         # One or more chars excluding\n            ( [^\\#;] | \\\\\\# | \\\\; ) +       # unescaped # and ; characters\n        )\n\n        \\]                                  # Closing square brace\n\n        
\\n\\n(?=[\\p{Alphabetic}])
\\n\\n\\$realInstanceReflection = [^{]++\\{([^}]++)\\}\\n\\n.*
\n\n\t(?<!\n\t    [\\N
\\n\\n++
\\n\\nBUNDLED WITH\\n\\s{2,}(
\\n\\\\part{([^\\{\\}]*)}
\n\\Q\u00e3\u0081\u0094\u00e7\u0099\u00bb\u00e9\u008c\u00b2\u00e3\u0080\u0081\u00e3\u0081\u0082\u00e3\u0082\u008a\u00e3\u0081\u008c\u00e3\u0081\u00a8\u00e3\u0081\u0086\u00e3\u0081\u0094\u00e3\u0081\u0096\u00e3\u0081\u0084\u00e3\u0081\u00be\u00e3\u0081\u0099\u00e3\u0080\u0082\u00e7\u0099\u00bb\u00e9\u008c\u00b2\u00e3\u0082\u0092\u00e6\u0089\u00bf\u00e8\u00aa\u008d\u00e3\u0081\u0099\u00e3\u0082\u008b\u00e5\u00a0\u00b4\u00e5\u0090\u0088\u00e3\u0081\u00af\n\u00e4\u00b8\u008b\u00e3\u0081\u00ae\u00e3\u0083\u00aa\u00e3\u0083\u00b3\u00e3\u0082\u00af\u00e3\u0082\u0092\u00e3\u0082\u00af\u00e3\u0083\u00aa\u00e3\u0083\u0083\u00e3\u0082\u00af\u00e3\u0081\u0097\u00e3\u0081\u00a6\u00e3\u0081\u008f\u00e3\u0081\u00a0\u00e3\u0081\u0095\u00e3\u0081\u0084\u00e3\u0080\u0082\n\nThank you for registration. To confirm your registration,\nplease click following link:\n\n\\Ehttp://localhost/(?:[^/]+/)*register\\.yatt\\?!confirm=1[;&]token=(?<token>[0-9a-f]+)\\Q\n\n\u00e5\u00bf\u0083\u00e5\u00bd\u0093\u00e3\u0081\u009f\u00e3\u0082\u008a\u00e3\u0081\u00ae\u00e7\u0084\u00a1\u00e3\u0081\u0084\u00e6\u0096\u00b9\u00e3\u0081\u00af\u00e3\u0080\u0081\u00e3\u0081\u0093\u00e3\u0081\u00ae\u00e3\u0083\u00a1\u00e3\u0083\u00bc\u00e3\u0083\u00ab\u00e3\u0081\u00af\u00e7\u00a0\u00b4\u00e6\u00a3\u0084\u00e3\u0081\u0097\u00e3\u0081\u00a6\u00e3\u0081\u008f\u00e3\u0081\u00a0\u00e3\u0081\u0095\u00e3\u0081\u0084\u00e3\u0080\u0082\n\nIf you have received this mail without having requested it,\nplease dispose this mail.\n\\E
\\n\\r?\\n(BREAKING|FIX|FEATURE):\\s*([^]*?)(?=\\r?\\n\\r?\\n|\\r?\\n?$)
\\n\\r?|\\r\\n?|,|;|\\\\
\\n\\s*\\\\item
\\n\\s*\\n\\s*\n        (?!(?:\n            \\\\chapter |\n            \\\\paragraph |\n            \\\\begin |\n            \\\\end |\n            \\\\part |\n            \\\\salto\n        ))\n        
\\n\\s+\\* @param (.*?)(?<= )\\$([a-zA-Z0-9_\\x7f-\\xff]++)
\\n\\s+\\/\\/\\s*disable\\s*debugging.*?[\\r\\n]+\\s+if\\s+\\(sharedState_yy\\.yydebug[^]+?\\}
\n\t     \\\\([\\da-fA-F]{2}|[()\\\\*])\n\t    
\n\t    (%d(?:
\n\t    \\A \\h+\n\n\t    (?<CHAR>\n\t\t\\H\n\t    )\n\n\t    \\h+\n\n\t    (?<CPNUM>\n\t\t\\p{ahex}{4,6}\n\t    )\n\n\t    \\t\n\n\t    (?<NAME>\n\t\t(?=  \\w )\n\t\t[A-Z0-9\\N{SPACE}\\N{HYPHEN-MINUS}] +\n\t\t(?<= \\w )\n\t    )\n\n\t    \\z\n\t
\n\t    \\b (?:\n\n\t\t     \\N{ae}lfe?\n\n                 |   \\N{oe}il\n                 |   \\N{oe}illade\n                 |   \\N{oe}ufs?\n                 |   \\N{oe}uvres?\n                 |  b\\N{oe}ufs?\n                 |  c\\N{oe}urs?\n                 | ch\\N{oe}nix\n                 |  m\\N{oe}urs\n                 |  v\\N{oe}ux?\n\n\t    ) \\b\n\t  |  (?<!man|ped)\\N{oe}uvr\n\t  | c\\N{oe}ur\n\t
\n\t    ^\n\t  (?:
\n\t# <C++ type>_<module_name>_[opt:_<module label>]_<process name which produced>.(dot)\t\n\t^([^_]+)_([^_]+)_([^_]*)_([^.]+[.])\n\t# <plain_size> <compressed_size>\n\t\\s([^\\s]+)\\s(.+)$\n
\n\t((?:$RE
\n\t\t        \\A (\n\t\t          [^\\n.]+\n\t\t          (?:\n\t\t            (?! \\. \\n | \\n{2} ) # disallow the first seperator here\n\t\t            [\\n.] (?! [ \\t]* @\\pL ) # disallow second seperator\n\t\t            [^\\n.]+\n\t\t          )*\n\t\t          \\.?\n\t\t        )\n\t\t        (?:\n\t\t          \\s* # first seperator (actually newlines but it's all whitespace)\n\t\t          (?! @\\pL ) # disallow the rest, to make sure this one doesn't match,\n\t\t          #if it doesn't exist\n\t\t          (\n\t\t            [^\\n]+\n\t\t            (?: \\n+\n\t\t              (?! [ \\t]* @\\pL ) # disallow second seperator (@param)\n\t\t              [^\\n]+\n\t\t            )*\n\t\t          )\n\t\t        )?\n\t\t        (\\s+ [\\s\\S]*)? # everything that follows\n\t\t        
\n\t\t     ((^|[;,.]|\\s+-\\s) # 1,2\n\t\t      \\s*\n\t\t      (Recorded (\\s+[io]n)? \\s* (:\\s*)? )? # 3, 4, 5\n\t\t      (\\d
\n\t\t  (?(DEFINE)\n\t\t\t (?<number>   -? (?= [1-9]|0(?!\\d) ) \\d+ (\\.\\d+)? ([eE] [+-]? \\d+)? )    \n\t\t\t (?<boolean>   true | false | null )\n\t\t\t (?<string>    \" ([^\"\\\\]* | \\\\ [\"\\\\bfnrt\\/] | \\\\ u [0-9a-f]{4} )* \" )\n\t\t\t (?<array>     \\[  (?:  (?&json)  (?: , (?&json)  )*  )?  \\s* \\] )\n\t\t\t (?<pair>      \\s* (?&string) \\s* : (?&json)  )\n\t\t\t (?<object>    \\{  (?:  (?&pair)  (?: , (?&pair)  )*  )?  \\s* \\} )\n\t\t\t (?<json>   \\s* (?: (?&number) | (?&boolean) | (?&string) | (?&array) | (?&object) ) \\s* )\n\t\t  )\n\t\t  \\A (?&json) \\Z\n\t\t  
\n\t\t  (?:\n\t\t\t^[ ]{0,
\n\t\t# Make captures for user and domain only ($1 and $2), using (?: on any other parenthesis to avoid captures\n\t\t^\n\t\t\t( # Begin first part of email address\n\t\t\t\t(?: # Option 1\n\t\t\t\t\t[^<>()[\\]\\\\.,;:\\s@\\\"]+ # Any character NOT in this set, at least one\n\t\t\t\t\t(?:\n\t\t\t\t\t\t\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+ # Followed by any character NOT in these set, starting with dot, in groups from 0 to many\n\t\t\t\t\t)*\n\t\t\t\t)\n\t\t\t\t|\n\t\t\t\t(?: # Option 2\n\t\t\t\t\t\".*?(?<!\\\\)\" # Anything between double quotes, including escaped double quotes\n\t\t\t\t)\n\t\t\t)\n\t\t\t[ ]*@[ ]*\n\t\t\t( # Beginning of second part of email address (domain name or ip address)\n\t\t\t\t(?:\n\t\t\t\t\t\\[ # If IP address, accepted only between brackets\n\t\t\t\t\t\t(?: # First group cannot begin in zero. From 1 to 255\n\t\t\t\t\t\t\t[1-9]\t\t\t# If it's only one char, from 1 to 9\n\t\t\t\t\t\t\t|\n\t\t\t\t\t\t\t[1-9][0-9]\t\t# If it's 2 chars, from 10 to 99\n\t\t\t\t\t\t\t|\n\t\t\t\t\t\t\t[1][0-9][0-9]\t# If it's 3 chars, from 100 to 199\n\t\t\t\t\t\t\t|\n\t\t\t\t\t\t\t[2][0-4][0-9]\t# If it's 3 chars, from 200 to 249\n\t\t\t\t\t\t\t|\n\t\t\t\t\t\t\t[2][5][0-5]\t\t# If it's 3 chars, from 250 to 255\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\\.\t# Separating dot\n\t\t\t\t\t\t(?: # Second and third groups can start in zero. From 0 to 255\n\t\t\t\t\t\t\t(?:\n\t\t\t\t\t\t\t\t[0-9]\t\t\t# If it's only one char, from 0 to 9\n\t\t\t\t\t\t\t\t|\n\t\t\t\t\t\t\t\t[1-9][0-9]\t\t# If it's 2 chars, from 10 to 99\n\t\t\t\t\t\t\t\t|\n\t\t\t\t\t\t\t\t[1][0-9][0-9]\t# If it's 3 chars, from 100 to 199\n\t\t\t\t\t\t\t\t|\n\t\t\t\t\t\t\t\t[2][0-4][0-9]\t# If it's 3 chars, from 200 to 249\n\t\t\t\t\t\t\t\t|\n\t\t\t\t\t\t\t\t[2][5][0-5]\t\t# If it's 3 chars, from 250 to 255\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\\.\t# Separating dot\n\t\t\t\t\t\t){2}\t# This must be present 2 times\n\t\t\t\t\t\t(?: # Fourth group cannot begin in zero and cannot end in 255. From 1 to 254\n\t\t\t\t\t\t\t[1-9]\t\t\t# If it's only one char, from 1 to 9\n\t\t\t\t\t\t\t|\n\t\t\t\t\t\t\t[1-9][0-9]\t\t# If it's 2 chars, from 10 to 99\n\t\t\t\t\t\t\t|\n\t\t\t\t\t\t\t[1][0-9][0-9]\t# If it's 3 chars, from 100 to 199\n\t\t\t\t\t\t\t|\n\t\t\t\t\t\t\t[2][0-4][0-9]\t# If it's 3 chars, from 200 to 249\n\t\t\t\t\t\t\t|\n\t\t\t\t\t\t\t[2][5][0-4]\t\t# If it's 3 chars, from 250 to 254\n\t\t\t\t\t\t)\n\t\t\t\t\t\t# No dot here\n\t\t\t\t\t\\]\n\t\t\t\t)\n\t\t\t\t|\n\t\t\t\t(?: # If domain, accept only groups of alphanumeric chars, can contain dashes only between chars\n\t\t\t\t\t(?:\t# First part also must have a dot for one to n parts\n\t\t\t\t\t\t(?:\n\t\t\t\t\t\t\t[a-zA-Z0-9]{1,2} # If it's one or two chars\n\t\t\t\t\t\t\t|\n\t\t\t\t\t\t\t[a-zA-Z0-9][a-zA-Z0-9\\-]+[a-zA-Z0-9] # If it's 3 or more chars\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\\. # Trailing dot\n\t\t\t\t\t)+\t# One or more times the same\n\t\t\t\t\t[a-zA-Z]{2,} # It must end with only letters, from 2 to n\n\t\t\t\t)\n\t\t\t)\n\t\t$\n\t
\n\t\t(?:\\n\\n|\\A)\n\t\t(\t\t\t\t\t\t\t\t\t# $1 = the code block\n\t\t  (?:\n\t\t\t(?:[ ]{
\n\t\t(\\$APPLICATION->SetTitle\\()\n\t\t(\n\t\t\t\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"                           # match double quoted string\n\t\t\t|\n\t\t\t'[^'\\\\]*(?:\\\\.[^'\\\\]*)*'                       # match single quoted string\n\t\t)\n\t\t(\\);)\n\t\t
\n\t\t(\\n)?\t\t\t\t\t\t\t# leading line = $1\n\t\t(^[ ]*)\t\t\t\t\t\t\t# leading whitespace = $2\n\t\t(
\n\t\t(\n\t\t\t^|\t\t\t\t\t\t# start of line OR\n\t\t\t[(-+=*\\/%^~\\s]\t\t\t# arithmetic symbol OR space\n\t\t)\n\t\t(?!exists\\()\t\t\t\t# not followed by \"exists(\"\n\t\t([A-Za-z]\\w*)\t\t\t\t# but followed by identifier\n\t\t
\n\t\t\\((?:\\?(?:[=!:]|&lt;[=!]|&gt;))?\n\t|\t\\[\\^?\n\t|\t\\\\(?:\\&\\w+;|.)\n\t|\t[\\*\\+\\?\\)\\]\\|]\n\t
\n\t\t\t(  \\\\  ([\\\\nrt\"]|U[A-Fa-f0-9]
\n\t\t\t(?(DEFINE)\n\t\t\t\t(?P<word> [\\w_]*[a-z][\\w_]* )\n\t\t\t)\n\t\t\t(?P<del> [.:])?(?P<key> (?&word))(\\((?P<throughColumn> (?&word))\\))?\n\t\t
\n\t\t\t(?<block>```php(?<code>[^`]++)```)\n\t\t\t\\s*\n\t\t\t(?<open>```\\w*|<pre>(?:<code>)?)\n\t\t\t(?<output>[^`]*)\n\t\t\t(?<close>```|</code></pre>)(?=\\n|$)\n\t\t
\n\t\t\t(\t\t# int is integer\n\t\t\t\\${(\\d+)(?: \\:((?:[^\\\\]|\\\\.)*?))?}     # ${int:default value} or ${int}\n\t\t\t|  \\$(\\d+)              # $int\n\t\t)
\n\t\t\t\\A/\n\t\t\t(?: 1(\\.1)?/
\n\t\t\t\t(.*?)\n\t\t\t\t(?| (?> \\\\ ( [\\[\\]\\|] ) \t(?{ \\&_parse_args_escape }) )\n\t\t\t\t  | (?> ( \\[ ) \t\t\t\t(?{ \\&_parse_args_open }) )\n\t\t\t\t  | (?> ( \\| ) \t\t\t\t(?{ \\&_parse_args_separator }) )\n\t\t\t\t  | (?> ( \\] ) \t\t\t\t(?{ \\&_parse_args_close }) )\n\t\t\t\t) \n\t\t\t\t
\n\t\t\t\t([a-z0-9_\\.]+) #property\n\t\t\t\t(?|\n\t\t\t\t\t(?:\\s+([a-z0-9]+[\\s_]?[a-z0-9]*)  #keyword\n\t\t\t\t\t(?:\\(|\\s+))|(?:\\s*([!=\\<\\>]+)\\s*) #condition\n\t\t\t\t)\n\t\t\t\t(.+) #value\n\t\t\t
\n\t\t\t\t\\[\\[\n\t\t\t\t\\s*+ # ignore leading whitespace, the *+ quantifier disallows backtracking\n\t\t\t\t:? # ignore optional leading colon\n\t\t\t\t([^\\]|]+) # 1. link target; page names cannot include ] or |\n\t\t\t\t(?:\\|\n\t\t\t\t\t# 2. link text\n\t\t\t\t\t# Stop matching at ]] without relying on backtracking.\n\t\t\t\t\t((?:]?[^\\]])*+)\n\t\t\t\t)?\n\t\t\t\t\\]\\]\n\t\t\t\t([^[]*) # 3. link trail (the text up until the next link)\n\t\t\t
\n\t\t\t\t\t(\t\t\t\t\t\t#$1\n\t\t\t\t\t\t<\t\t\t\t\t#tag beginning\n\t\t\t\t\t\t\t$class\n\t\t\t\t\t\t\t::\n\t\t\t\t\t\t\t(\t\t\t\t#$2 v\n\t\t\t\t\t\t\t\t
\n\t\t\t\t\t\t\t(?:\n\t\t\t\t\t\t\t\t[\\\\\\$]\\$\t\t\t\t\t# escaped dollar\n\t\t\t\t\t\t\t     \\{
\n\t\t\t\t\t\t\t+ B_rad * sin(theta)*cos_theta_0;\n\t\t\t\t\t}\n\t\t\t\t\tapc_gp_fill_poly (widget_handle, N_points, points_to_plot);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tonMouseMove => sub {\n\t\t(my $self, undef, $x, $y) = @_;\n\t\t$self->notify('Paint');\n\t},\n);\n\nmy @points;\nmy $pi = 2*atan2(1, 0);\nmy $N_points = 200;\n\nPrima::MainWindow-> new( text => 'Pure Perl',\n\tonPaint => sub {\n\t\tmy ($self, $canvas) = @_;\n\t\treturn $self->repaint if $self->get_paint_state != 1;\n\t\t$self->clear;\n\t\t\n\t\t# Some pre-calculations\n\t\tmy $rotation = atan2($y - 250, $x - 250);\n\t\tmy $sin_theta_0 = sin($rotation);\n\t\tmy $cos_theta_0 = cos($rotation);\n\t\tmy $theta_inc = $pi 
\n\t\t\t\t\t^(\n\t\t\t\t\t\tController\n\t\t\t\t\t|\n\t\t\t\t\t\t(?P<subpackageKey>.+)\\\\Controller\n\t\t\t\t\t)\n\t\t\t\t\t\\\\(?P<controllerName>[a-z\\\\]+)Controller\n\t\t\t\t\t$
\n\t\t\t\t\tname=\"?\\Q$param\\E\"?;\n\t\t\t\t\t\\s+\n\t\t\t\t\tfilename=\"?([^\\\"]*)\"?\n\t\t\t\t
\n\t\t\t\t^ [\\t ]* (?:\n\t\t\t\t\t(?:final\\s+)? (?:abstract\\s+)? (?:class|interface|trait) \\s+\n\t\t\t\t\t(?P<class> [a-zA-Z0-9_]+)\n\t\t\t\t|\n\t\t\t\t\tclass_alias \\s* \\( \\s*\n\t\t\t\t\t\t(['\"]) (?P<original> [^'\"]+) \\g{-2} \\s* , \\s*\n\t\t\t\t\t\t(['\"]) (?P<alias> [^'\"]+ ) \\g{-2} \\s*\n\t\t\t\t\t\\) \\s* ;\n\t\t\t\t|\n\t\t\t\t\tclass_alias \\s* \\( \\s*\n\t\t\t\t\t\t(?P<originalStatic> [a-zA-Z0-9_]+)::class \\s* , \\s*\n\t\t\t\t\t\t(['\"]) (?P<aliasString> [^'\"]+ ) \\g{-2} \\s*\n\t\t\t\t\t\\) \\s* ;\n\t\t\t\t)\n\t\t\t
\n\t\t\t\tif ((double)candidate 
\n\t\t\t^(.*?)\n\t\t\t(?<!\\\\)\n\t\t\t$prefix\n\t\t\t(?:(\\w*)\n\t\t\t([^\\|><]*))?\n\t\t\t((?:\\||>>?|<<?).+)?\n\t\t\t$\n\t
\n\t\t\t^(\n\t\t\t\tController\n\t\t\t|\n\t\t\t\t(?P<subpackageKey>.+)\\\\Controller\n\t\t\t)\n\t\t\t\\\\(?P<controllerName>[a-z\\\\]+)Controller\n\t\t\t$
\n\t\t^[ ]*\\[(.+)\\]:\t\t# id = $1\n\t\t  [ ]*\n\t\t  \\n?\t\t\t\t# maybe *one* newline\n\t\t  [ ]*\n\t\t<?(\\S+?)>?\t\t\t\t# url = $2\n\t\t  [ ]*\n\t\t  \\n?\t\t\t\t# maybe one newline\n\t\t  [ ]*\n\t\t(?:\n\t\t\t# Titles are delimited by \"quotes\" or (parens).\n\t\t\t[\"(]\n\t\t\t(.+?)\t\t\t# title = $3\n\t\t\t[\")]\t\t\t# Matching ) or \"\n\t\t\t[ ]*\n\t\t)?\t# title is optional\n\t\t(?:\\n+|\\Z)\n\t  
\n\t\t^\n\t\t( (?: [^\\e]* ${color_re} ) *+ )\n\t\t( .*? )\n\t\t( ${alphanum_re}+ )\n\t\t\\z\n\t
\n\t\t^\t\t\t\t\t\t# Start of line\n\t\t<(
\n\t\t^insert\\s+\n\t\tinto\\s+\n\t\t((?:\\w+|\\w+\\.\\w+))\\s+?\\(\t\t\t# )\n\t\t
\n\t\tSafefree(prime_list);\n\t\treturn candidate;\n\t}\n}\n\nsub c_blocks_sub_Nth_prime {\n\tmy $N = shift;\n\tmy $to_return;\n\tcblock { sv_setiv($to_return, get_Nth_prime(SvIV($N))); }\n\treturn $to_return;\n}\n\nuse Time::HiRes qw(gettimeofday tv_interval);\n\nmy $N_iterations = 1000;\nfor my $log_N (1, 1.5, 2, 2.5, 3, 3.5, 4) {\n\tmy $N = int(10**$log_N);\n\tprint \"--- N = $N ---\\n\";\n\t\n\t# C::Blocks test\n\tmy $C_Blocks_accum = 0;\n\tmy $C_Blocks_result;\n\tfor (1 .. $N_iterations) {\n\t\tmy $t0 = [gettimeofday];\n\t\tcblock { sv_setiv($C_Blocks_result, get_Nth_prime(SvIV($N))); }\n\t\tmy $ellapsed = tv_interval ($t0);\n\t\t$C_Blocks_accum += $ellapsed;\n\t}\n\tmy $C_Blocks_time = $C_Blocks_accum 
\n\te(text|b?ook)\n\t\\s*\n\t(\\#\\s*(?P<etextid_front>\\d+)\n\t|\n\t(?P<etextid_back>\\d+)\\s*\\#)\n\t
\n^(?:\\s+)?                          # Allow whitespace at beginning\n(?P<src>\\S+)                       # Find the path\n(?:\\s+)?                           # Whitespace\n(?:(?:lang:)(?P<lang>\\S+))?        # Optional language\n(?:\\s+)?                           # Whitespace\n(?:(?:lines:)(?P<lines>\\d+-\\d+))?  # Optional lines\n(?:\\s+)?                           # Whitespace\n(?P<hidefilename>:hidefilename:)?  # Hidefilename flag\n(?:\\s+)?                           # Whitespace\n(?:(?:codec:)(?P<codec>\\S+))?        # Optional language\n(?:\\s+)?                           # Whitespace\n(?P<title>.+)?$                    # Optional title\n
\n^(?P<chars>[0-9]{4})\n(?P<stationid>......)\n(?P<wban>.....)\n(?P<yyyymmdd>[0-9]{8})\n(?P<hhmi>[0-9]{4})\n(?P<srcflag>.)\n(?P<lat>[\\+\\-][0-9]{5})\n(?P<lon>[\\+\\-][0-9]{6})\n(?P<report_type>.....)\n(?P<elevation>[\\+\\-][0-9]{4})\n(?P<call_id>.....)\n(?P<qc_process>....)\n(?P<drct>[0-9]{3})\n(?P<drct_qc>.)\n(?P<wind_code>.)\n(?P<wind_speed_mps>[0-9]{4})\n(?P<wind_speed_mps_qc>.)\n(?P<ceiling_m>[0-9]{5})\n(?P<ceiling_m_qc>.)\n(?P<ceiling_m_how>.)\n(?P<ceiling_m_cavok>.)\n(?P<vsby_m>[0-9]{6})\n(?P<vsby_m_qc>.)\n(?P<vsby_m_variable>.)\n(?P<vsby_m_variable_qc>.)\n(?P<airtemp_c>[\\+\\-][0-9]{4})\n(?P<airtemp_c_qc>.)\n(?P<dewpointtemp_c>[\\+\\-][0-9]{4})\n(?P<dewpointtemp_c_qc>.)\n(?P<mslp_hpa>[0-9]{5})\n(?P<mslp_hpa_qc>.)\n
\n^[ \\t]* i    [ ] = [ \\t]+ (?P<iteration> \\d+),\n [ \\t]* time [ ] = [ \\t]+ (?P<time> [\\+\\-]?  ( \\d*[\\.]\\d+  | \\d+[\\.]?\\d* )  ([Ee][\\+\\-]?\\d+)? ),\n [ \\t]* E    [ ] = [ \\t]+ (?P<energy> [\\+\\-]?  ( \\d*[\\.]\\d+  | \\d+[\\.]?\\d* )  ([Ee][\\+\\-]?\\d+)? )\n
\n^\n  (?P<protocol>\\w+)       # protocol\n  ://\n  (                       # optional @ section\n    (?P<user>\\w+)\n    (:(?P<password>\\w+))? # optional password\n  @)?\n  (?P<host>[^:]+)         # host or path\n  (:(?P<port>\\d+))?       # optional port number\n$\n
\n^\nv?\n(?:(?P<epoch>\\d+)!)?\n(?P<major>\\d+)\n(?:\\.(?P<minor>\\d+))?\n(?:\\.(?P<patch>\\d+))?\n(?P<prereleasetype>a|b|rc)?\n(?P<prereleaseversion>\\d+)?\n(?:\\.post(?P<post>\\d+))?\n(?:\\.dev(?P<dev>\\d+))?\n(\\+(?P<local>[\\.0-9A-Za-z-]*))?\n$\n
\n^\nv?\n(?:(?P<major>\\d+)\\.?)\n(?:(?P<minor>\\d+)?\\.?)\n(?:(?P<patch>\\d+)?)\n(?P<prerelease>-(?P<commit_count>\\d+)-(?P<commit>[a-z0-9]*)(-(?P<dirty>\\w*))?)?\n(\\+(?P<build>[\\.0-9A-Za-z-]*))?\n$\n
\n_\\ *?\\{\n(?P<a>[^{}]*?) \\\\\\\\\n(?P<b>[^{}]*?) \\}\n
\\n{2}+
\\N{ae}\\N{acute}|[\\N{eth}\\N{thorn}]
\\N{CARRIAGE RETURN}
\\N{CARRIAGE RETURN}\\N{LINE FEED}
\\N{GREEK SMALL LETTER MU}
\\N{LEFTWARDS ARROW}
\\N{LINE FEED}
\\N{LINE FEED}\\N{CARRIAGE RETURN}
\\N{MULTIPLICATION SIGN}
\\N{RIGHTWARDS ARROW}
\\N{U+00A0}
\\N{U+00A0}$
\\N{WHITE CIRCLE}|\\N{BULLSEYE}
\\\\\\n|\\\\(\\\\|<%)
\\\\n|\\\\N
\n<(?P<con>\n[^\\|<>]+\n\\|\n[^\\|<>]+\n(?:\n  \\|[^\\|<>]+ #optional middle\n|)\n)>\n
\n<[^\\>]*\nfunction \\s+\n(?P<name>[^\\s\\>]+)\n[^\\>]* \\>
\nAREA\\s(?P<areanum>[0-9]+)\\.\\.\\.FROM\\s(?P<locs>[0-9A-Z \\-]+)\\n\n
\\\\NestedGreaterGreater 
\\\\NestedLessLess 
\\\\newcommand\\{ \\\\([a-z]+) \\} \\[ (\\d+) \\](\\{.*)
\\\\NG 
\\\\node_modules\\\\
\\\\not\\\\($NEG_SYMB_RE)
\\\\not\\\\($re)
\\\\not\\\\geq 
\\\\not\\\\in 
\\\\not\\\\kern\\-0.3em\\\\times 
\\\\not\\\\leq 
\\\\not\\\\prec 
\\\\not\\\\preceq 
\\\\NotEqualTilde 
\\\\NotGreaterGreater 
\\\\NotHumpDownHump 
\\\\NotHumpEqual 
\\\\NotLeftTriangleBar 
\\\\NotLessLess 
\\\\NotNestedGreaterGreater 
\\\\NotNestedLessLess 
\\\\NotPrecedesTilde 
\\\\NotRightTriangleBar 
\\\\NotSquareSubset 
\\\\NotSquareSuperset 
\\\\NotSucceedsTilde 
\nOUTLOOK\\sVALID\\s(?P<begin>[0-9]{6})-(?P<end>[0-9]{6})\\n\n
\\nreturn (\\$this->valueHolder[0-9a-f]++)(->[^;]++);$
\nWI\\s+(?P<distance>[0-9]*)NM\\s+OF\\s+\n
\\\\O 
\\\\o 
\\\\o'(.)(.)'
\\\\o[0-7]+|\\\\x[0-9A-Fa-f]+|\\\\[0-9]+
\\\\o\\/
\\\\odot 
\\\\OE 
\\\\oe 
\\\\oint 
\\\\omega 
\\\\Omega 
\\\\ominus 
\\opacity:.100
\\\\openbracketleft 
\\\\openbracketright 
\\\\operatorname{(.*)}
\\\\oplus 
\\ORDER BY\\s(?!.*\\ORDER BY\\s)
\\ORDER\\b
\\origin([\\\\]+|\\/)node_modules
\\\\original 
\\\\oslash 
\\\\otimes 
\\p
\\\\p
\\\\p\\{(..?)\\}
\\\\p\\{Is
\\p{
\\p{$code}
\\\\p{\\w+}
\\p{^Alnum}
\\p{abc}
\\p{AHex}
\\p{AHex}+
\\p{Alnum}
\\p{Alnum}[-_\\.\\p{Alnum}]{0,48}\\p{Alnum}
\\p{Alnum}+(?:'\\p{Alnum}+)*
\\p{Alnum}+(\\+\\p{Alnum}+)?:/$
\\p{Alnum}+(\\+\\p{Alnum}+)?://.*
\\p{Alpha}
\\p{Alpha}+|\\p{Digit}+
\\p{Alphabetic}
\\P{Alphabetic}+
\\p{Alphabetic}+
\\p{Any}
\\P{Any}+
\\p{Any}+
\\p{Arabic}
\\p{ASCII
\\p{ASCII_Hex_Digit}
\\P{ASCII}
\\P{ascii}
\\p{AsciI}
\\p{ASCII}
\\p{ASCII}*
\\P{ASCII}|^(?:(?i)$IDNA_PREFIX)
\\P{ascii}+
\\P{ASCII}+
\\p{ASCII}+
\\P{Assigned}
\\P{Assigned}+
\\p{Assigned}+
\\p{Bc:EN}.*\\p{Bc:AN}|\\p{Bc:AN}.*\\p{Bc:EN}
\\p{bc=AL}+
\\p{bc=Arabic_Letter}+
\\p{bc=Left_To_Right}+
\\p{BC=NSM}
\\p{bc=R}
\\p{bc=R}|\\p{bc=AL}
\\p{Bidi_C}
\\p{Bidi_C}+
\\p{Bidi_Class=L}+
\\p{Bidi_Control}
\\p{Bidi_Control}+
\\p{Bidi_M}
\\p{Bidi_Mirrored}
\\p{blank}
\\p{Blank}
\\p{Blank}([Nn])([Oo])([Tt]) ([Ll])([Ii])([Kk])([Ee])\\p{Blank}
\\p{Blank}+
\\p{blk=BasicLatin}
\\p{blk=CJK_Unified_Ideographs}+
\\p{blk=CJK}+
\\p{blk=Greek_And_Coptic}
\\p{blk=Greek}
\\p{blk=Hiragana}
\\p{blk=Latin_1_Sup}+
\\p{blk=Latin_1_Supplement}+
\\p{blk=Latin_1}+
\\p{Block=ASCII}+
\\p{block=basic_latin}
\\p{Block=Basic_Latin}+
\\p{block=BasicLatin}
\\p{block=Domino Tiles}+
\\p{block=Emoticons}+
\\p{block=Enclosed Alphanumeric Supplement}+
\\p{block=Mahjong Tiles}+
\\p{block=Miscellaneous Symbols And Pictographs}+
\\p{block=Miscellaneous Symbols}+
\\p{block=Playing Cards}+
\\p{block=Transport and Map Symbols}+
\\p{Bopomofo}
\\p{Case_Ignorable}
\\p{CI}
\\p{Cntrl}
\\p{Control}
\\p{CWCF}
\\p{CWCM}
\\p{CWL}
\\p{CWT}
\\p{CWU}
\\p{Cyrillic}
\\p{Dash}
\\p{Dash}\\K\\h*\\n
\\p{Default_Ignorable_Code_Point}
\\p{Dep}
\\p{Deprecated}
\\p{DI}
\\p{Dia}
\\p{Diacritic}
\\p{Digit}
\\p{Digit}+
\\p{Digit}cd
\\p{EastAsianWidth:W}
\\p{Emoji_Component}
\\p{Emoji_Modifier_Base}
\\p{Emoji_Modifier}
\\p{Emoji_Presentation}
\\p{Emoji}
\\p{Emoji}(?:\\uFE0F|\\uFE0E)?|\\p{Emoji_Presentation}|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?
\\p{Emoji}\\uFE0E?|\\P{Emoji_Presentation}
\\p{Emoji}\\uFE0F|\\p{Emoji_Presentation}|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?
\\p{Ethiopic}
\\p{Ext}
\\p{Extender}
\\\\p{foo}
\\p{FORMAT}
\\p{GC=Ll}
\\p{gc=Ll}
\\p{gc=Lu}
\\p{General_Category=L}
\\p{general_category=Lu}
\\p{General_Category=Math_Symbol}
\\p{Gr_Base}
\\p{Gr_Ext}
\\p{Graph}
\\p{Grapheme_Base}
\\p{Grapheme_Extend}
\\p{Greek}
\\p{Han}
\\p{Han}|\\p{Hangul}|\\p{Hiragana}|\\p{Katakana}
\\p{Han}|\\p{Hangul}|\\p{Hiragana}|\\p{Katakana}|\\w+
\\p{Han}|\\p{Katakana}|\\p{Hiragana}|\\p{Hangul}
\\p{Han}+
\\p{Hangul}
\\p{Hangul}+
\\p{Hebrew}
\\p{Hex_Digit}
\\p{Hex}
\\p{hiraganA}
\\p{Hiragana}
\\p{Hiragana}|\\p{Katakana}
\\p{Hiragana}|\\p{Katakana}|\\p{Han}
\\p{Hiragana}+
\\p{Changes_When_Casefolded}
\\p{Changes_When_Casemapped}
\\p{Changes_When_Lowercased}
\\p{Changes_When_Titlecased}
\\p{Changes_When_Uppercased}
\\p{ID_Continue}
\\p{ID_Start}
\\p{IDC}
\\p{Ideo}
\\p{Ideo}+
\\p{Ideographic}
\\p{IDS_Binary_Operator}
\\p{IDS_Trinary_Operator}
\\p{IDS}
\\p{IDSB}
\\p{IDST}
\\p{InArabic}
\\P{InArabic}+
\\P{InBasic_Latin}
\\p{InBasicLatin}
\\p{InCombiningDiacriticalMarks}
\\p{InCombiningDiacriticalMarks}+
\\p{InCyrillic}
\\p{InDoCoMoPictograms}
\\p{InEmojiAny}
\\p{InEmojiDoCoMo}
\\p{InEmojiGoogle}
\\p{InEmojiKDDIapp}
\\p{InEmojiKDDIweb}
\\p{InEmojiMixed}
\\p{InEmojiSoftBank}
\\p{InEmojiUnicode}
\\p{InEthiopic}
\\p{InFullwidth}
\\p{InGreek}
\\p{InGreekAndCoptic}
\\p{InGujarati}
\\p{InHankakuKatakana}
\\p{InHebrew}
\\P{InHiragana}
\\p{InHiragana}
\\p{InHiragana}|\\p{InCJKUnifiedIdeographs}
\\p{InCherokee}
\\p{InKatakana}
\\P{InKatakana}
\\p{InKDDIAutoPictograms}
\\P{InMathematicalAlphanumericSymbols}
\\p{InSoftBankPictograms}
\\p{IsAlpha}
\\P{IsAlpha}+
\\p{IsAlpha}e
\\p{IsAlphabetic}
\\P{IsAlphabetic}
\\p{IsAlphabetic}+
\\p{IsAssigned}
\\p{IsC}
\\p{IsC}+
\\p{IsControl}
\\p{IsIdeographic}
\\p{IsIDNADot}
\\p{IsIgnored}
\\p{IsJoinControl}
\\p{IsLatin}
\\p{IsLetter}
\\p{IsLower}
\\p{IsLowerCase}
\\p{IsLu}
\\p{IsM}
\\p{IsNoncharacterCodePoint}
\\p{IsP}
\\p{IsSpace}+
\\p{IsTitle}|\\p{IsUpper}
\\p{IsTitleCase}
\\p{IsUnknown}
\\p{IsUpper}
\\p{IsUpperCase}
\\p{IsWhiteSpace}
\\p{IsWord}-\\p{IsWord}
\\p{IsZ}
\\p{IsZero}
\\p{IsZZ}
\\p{javaAlphabetic}
\\p{javaIdeographic}
\\p{javaJavaIdentifierStart}\\p{javaJavaIdentifierPart}*
\\p{javaLowerCase}
\\p{javaLowerCase}+
\\p{javaSpaceChar}
\\p{javaUpperCase}
\\p{javaWhitespace}+
\\p{Join_C}
\\p{Join_Control}
\\p{Js}\\p{Jp}*
\\p{Katakana}+
\\p{L&}
\\p{L_}
\\p{L}\\K[\u2018\u2019](?=\\p{L})
\\p{Latin}
\\p{lb=AL}
\\p{LC}
\\P{Letter}
\\p{Letter}${chartypes{notacute}}*\\x{0301}${chartypes{notacute}}*\u00c2\u00b4$
\\p{Letter}\\p{NonspacingMark}*$
\\p{Letter}+
\\p{Line_Break=Glue}
\\p{Lingua::AR::Regexp::IsTashkeel}
\\p{Lingua::AR::Tashkeel::InOnesToKeepIn}
\\p{Ll}\\K_(\\pL)
\\p{LOE}
\\p{Logical_Order_Exception}
\\p{Lower}
\\p{Lower}+
\\p{Lowercase_Letter}
\\p{Lowercase}
\\p{Math_Symbol}
\\p{Math}
\\p{NChar}
\\p{Noncharacter_Code_Point}
\\p{Nonspacing_Mark}
\\p{NonspacingMark}
\\p{Pat_Syn}
\\p{Pattern_Syntax}
\\p{Pattern_White_Space}
\\p{PerlSpace}+\\z
\\P{Print}
\\p{Print}
\\p{Print}*
\\p{Private_Use}
\\p{Punct}
\\p{Punct}|[\\x00-\\x08\\x0A-\\x1F\\x7F]
\\p{Punct}|\\d
\\p{Punct}|\\p{Cntrl}
\\p{Punct}|\\p{IsPunctuation}
\\p{Punct}+
\\p{QMark}
\\p{Quotation_Mark}
\\p{Radical}
\\p{Regional_Indicator}
\\p{sc=Greek}
\\p{sc=Grek}
\\p{sc=Hira}
\\p{sc=Hiragana}
\\p{sc=Latin}
\\p{sc=Phnx}
\\p{sc=Phoenician}
\\p{Script_Extensions=Anatolian_Hieroglyphs}
\\p{Script_Extensions=Bopo}+
\\p{Script_Extensions=Cypriot}+
\\p{Script_Extensions=Hang}+
\\p{Script_Extensions=Hani}+
\\p{Script_Extensions=Hira}+
\\p{Script_Extensions=Kana}+
\\p{Script_Extensions=Makasar}
\\p{Script_Extensions=Yiii}+
\\p{script=Common}
\\p{Script=Common}+
\\p{Script=Cypriot}+
\\p{Script=Han}+
\\p{Script=Hani}+
\\P{Script=Hiragana}
\\p{Script=Hiragana}
\\p{script=Latin}
\\p{Script=Latin}+
\\p{Script=Latn}+
\\p{scx=Bopomofo}+
\\p{scx=Cprt}+
\\p{scx=Han}+
\\p{scx=Hangul}+
\\p{scx=Hiragana}+
\\p{scx=Katakana}+
\\p{scx=Yi}+
\\p{SD}
\\p{Sentence_Terminal}
\\p{Soft_Dotted}
\\p{Space}
\\p{Space}*
\\p{Space}+
\\P{Space}+
\\p{Space}+\\z
\\p{STerm}
\\p{Term}
\\p{Terminal_Punctuation}
\\p{TerminalPunctuation}
\\p{UIdeo}
\\p{Unified_Ideograph}
\\p{Unknown}
\\P{Upper}
\\p{Upper}
\\p{Upper}.*
\\p{Upper}.+
\\p{Upper}\\K
\\p{Upper}\\p{Lower}+\\s+(?:\\p{Lower}+\\s+)?'[\\w\\s]+'
\\p{Upper}+
\\p{Uppercase_Letter}
\\p{Uppercase}
\\p{Uppercase}+
\\p{Variation_Selector}
\\p{VS}
\\p{White Space}
\\p{White_Space}
\\p{White_Space}+
\\p{Word}
\\p{Word}{3,}
\\P{Word}+
\\p{Word}+
\\p{Word}+( \\p{Word}+)*(?= \u00b7)
\\p{Word}+( \\S)?( \\p{Word}+( \\S)?)*(?= \u00b7)
\\p{WSpace}
\\p{XDigit}
\\p{XDigit}*
\\p{XDigit}{2}
\\p{XID_Continue}
\\p{XID_Start}
\\p{XIDC}
\\p{XIDS}
\\P{XPosixPrint}
\\p{XPosixPunct}
\\\\packages.*\\\\meteor\\.bat
\\\\pandoc$
\\\\par
\\\\par\\b
\\\\paragraph\\{(.*?)\\}
\\\\parallel 
\\\\param (.*?) 
\\\\pard*
\\\\partial 
\\\\path\\|(.*?)\\|
\\\\patterns\\{
\\\\patterns\\{([^\\}]*)\\}
\\\\patterns{.*
\\\\pause
\\pC
\\\\period
\\\\perl$
\\\\perp 
\\\\perspcorrespond 
\\\\phi 
\\\\Phi 
\\\\Pi 
\\\\pi 
\\\\pipe\\\\winpty-control
\\\\pisces 
\\\\Pisymbol\\{ppi020\\}\\{105\\}
\\\\Pisymbol\\{ppi020\\}\\{117\\}
\\\\Pisymbol\\{ppi022\\}\\{87\\}
\\\\pitchfork 
\\pL
\\PL
\\pL*[0-9][\\pL0-9]*
\\pL\\pL\\pP*[.!?]\\s+\\S
\\pL+
\\PL+
\\\\pluto 
\\\\pm 
\\pM
\\pM*
\\PM\\pM*|.
\\pM+
\\pN
\\pP
\\PP$
\\pP|\\pS|\\s*|\\t|\\r|\\n
\\pP+
\\\\prec 
\\\\precapprox 
\\\\preccurlyeq 
\\\\precedesnotsimilar 
\\\\preceq 
\\\\precnapprox 
\\\\precneqq 
\\\\Problem name: (.+)
\\\\probref{(.*?)}
\\\\prod 
\\\\propref{(.*?)}
\\\\propto 
\\\\proref{(.*?)}
\\\\protect
\\pS
\\pS+
\\\\psi 
\\\\Psi 
\\px
\\\\PYGZsq{}
\\\\python\\d\\d(m|d|u)?.dll$
\\pZ
\\pZ|\\s
\\Q
\\\\q
\\\\Q
\\Q $stopword \\E
\\Q \\E
\\Q = \"abc\"\\E$
\\Q = map[string]string = {[\"abc\"] = \"def\", [\"ghi\"] = \"jkl\"}\\E$
\\Q = map[string]string = {[\"ghi\"] = \"jkl\", [\"abc\"] = \"def\"}\\E$
\\Q at $c[1] line $c[2]\\E\\.\\n\\z
\\Q!\\@\\$%^&****unlikely_clade_separator***!\\@\\$%^&****\\E
\\Q$$block[-1]\\E$
\\Q$$self{BOLD}
\\Q$$self{config}{anon_placeholder}\\E
\\Q$$self{NORM}
\\Q$$self{UNDL}
\\Q$(\\E(${MACRO_RE})\\Q)\\E
\\Q$(\\E(INSTALL(?!DIRS)${MACRO_RE})\\Q)\\E
\\Q$(BASEEXT)\\E
\\Q$(DFSEP)\\E
\\Q$(PERL_INC)\\E
\\Q$/\\E
\\Q$/\\E$
\\Q$;\\E....\\Q$;\\E
\\Q$;\\EHPL_PH(\\d+)\\Q$;\\E
\\Q$\\E
\\Q$_
\\Q$_[0]{separator}
\\Q$_[0]->{name_sep}\\E
\\Q$_[1]\\E
\\Q$_[1]\\E$
\\Q$_\\E
\\Q$_\\E$
\\Q$_\\E\\s*
\\Q${comment}\\E
\\Q${currency_name}\\E
\\Q${del}\\E
\\Q${delim}\\E
\\Q${delim}\\E([imsx]*)$
\\Q${flags}\\E$
\\Q${inc}\\E\\Z
\\Q${key}\\E
\\Q${name}-${version}\\E\\/lib
\\Q${old}\\E
\\Q${ppport}\\E
\\Q${quos}\\E
\\Q${sep}\\E$
\\Q${start}\\E(\\S)
\\Q${suffix}\\E$
\\Q${VCS::CMSynergy::FS}\\E
\\Q${VCS::CMSynergy::RS}\\E
\\Q${XML::XQL::DirNode::SEP}\\E$
\\Q${xshelper}\\E
\\Q$0\\E
\\Q$1\\E
\\Q$1\\E([a-z]*)$
\\Q$a\\E
\\Q$a\\E$
\\Q$acstr\\E$
\\Q$action\\E
\\Q$action\\E=
\\Q$action\\E=(.*?)\\s*($|;)
\\Q$address\\E
\\Q$address\\E is undeliverable
\\Q$ALIAS_START\\E.*\\Q$ALIAS_END\\E
\\Q$allow
\\Q$also\\E
\\Q$alta{'ienc_pre'}\\E([^\\\"]*)\\Q$alta{'ienc_pst'}\\E
\\Q$alta{'kls_pre'}\\E([^\\\"]*)\\Q$alta{'kls_pst'}\\E
\\Q$alta{'pre'}\\E(.*)\\Q$alta{'pst'}\\E
\\Q$alta{'q_pre'}\\E([^\\\"]*)\\Q$alta{'q_pst'}\\E
\\Q$amen\\E$
\\Q$anno\\E
\\Q$apropos_option
\\Q$args_i\\E
\\Q$args{domain_name}
\\Q$arch\\E
\\Q$b\\E$
\\Q$b\\E[.]$e$
\\Q$bar\\E<
\\Q$base_path\\E\\/$ref_path/
\\Q$base2\\E
\\Q$baseDir\\E\\/?
\\Q$baseUrl
\\Q$bb_mark\\E
\\Q$bcc\\E
\\Q$before_angles\\E$
\\Q$before_re\\E(.+)\\Q$after_re\\E
\\Q$bn\\E$
\\Q$bn_match\\E
\\Q$break_str\\E
\\Q$build_folder\\E
\\Q$bundle_filename\\E$
\\Q$c
\\Q$C\\E
\\Q$c_comma
\\Q$candidate\\E$
\\Q$cc\\E
\\Q$cf->
\\Q$class\\E
\\Q$class_dir\\E
\\Q$close
\\Q$close\\E$
\\Q$closedelim\\E
\\Q$co->{$color}\\E
\\Q$code\\E
\\Q$code_block_prefix\\E
\\Q$collocation
\\Q$com_open\\E(.*?)\\Q$com_close\\E
\\Q$comma 
\\\\\\Q$command\\E
\\\\\\Q$command\\E(\\W|$)
\\Q$comment\\E
\\Q$comment_marker\\E
\\Q$complete_request\\E
\\Q$complete_word\\E\\s*\\z
\\Q$Config::Config{'path_sep'}
\\Q$Config::Config{path_sep}\\E
\\Q$Config_libext\\E\\z
\\Q$Config{_a}\\E$
\\Q$Config{_exe}$
\\Q$Config{_exe}\\E$
\\Q$Config{archname}\\E.
\\Q$Config{path_sep}
\\Q$Config{path_sep}\\E
\\Q$cont\\E$
\\Q$cookie_domain\\E$
\\Q$cur
\\Q$curword\\E
\\Q$cxx_version\\E
\\Q$d
\\Q$d\\E
\\Q$data[-2]\\E
\\Q$data->{path_col_sep}\\E
\\Q$deci_sep\\E.*
\\Q$decimal\\E\\d\\d{$dlen,}$
\\Q$DecimalSeparator\\E
\\Q$DEF{DATESEP}\\E
\\Q$Defaults{dir_sep}
\\Q$Defaults{rc_dir}$Defaults{dir_sep}\\E(.*)
\\Q$defp\\E([^\\n]*?)($str|\\n|$)
\\Q$del$del
\\Q$del\\E
\\Q$delim
\\Q$DELIM
\\Q$delim\\E
\\Q$DELIM\\E$word$
\\Q$DELIM\\E$word\\Q$DELIM\\E
\\Q$delim\\E\\s*
\\Q$delim\\E+
\\Q$DELIMITER\\E
\\Q$delimiter\\E
\\Q$delimiter\\E *
\\Q$dir\\E.
\\Q$dir_parent
\\Q$dist
\\Q$dist\\E[^/]*/($ignore_pat)$
\\Q$dist\\E[^/]*/($ignore_pat)/
\\Q$divsig\\E
\\Q$divsig\\E(\\d*)
\\Q$domain\\E$
\\Q$domain\\E\\z
\\Q$domain_name
\\Q$dwimop
\\Q$e\\E
\\Q$eaddrinuse_msg\\E
\\Q$emails{$ident}{ident}\\E
\\Q$embedded_idtype_marker\\E
\\Q$embedded_idtype_marker\\E(.*)
\\Q$enclose\\E
\\Q$end_mark
\\Q$ending\\E$
\\Q$entire_key\\E(?:\\n|\\f|\\r)?
\\Q$entry_delim\\E
\\Q$EOL
\\Q$eol\\E$
\\Q$eol\\E\\z
\\Q$esc\\E
\\Q$esc\\E(.)
\\Q$ESC{ASC}\\E\n        (\\Q$ESC{KANA}\\E|\\Q$ESC{JIS_0212}\\E|\\Q$ESC{JIS_0208}\\E)
\\Q$ESC{ASC}\\E\n\t    (\\Q$ESC{KANA}\\E|\\Q$ESC_JISX0213_1\\E|\\Q$ESC_JISX0213_2\\E)
\\Q$ESC{ASC}\\E\n\t    (\\Q$ESC{KANA}\\E|\\Q$ESC{JIS_0212}\\E|\\Q$ESC{JIS_0208}\\E)
\\\\\\Q$escape\\E
\\Q$escape\\E
\\Q$eseq$eseq\\E
\\Q$eseq\\E(?!\\Q$eseq\\E)
\\Q$esi\\E
\\Q$exclude\\E
\\Q$exclude_file\\E
\\Q$exe\\E$
\\Q$exe_ext\\E$
\\Q$exp_result
\\Q$expected_location\\E$
\\Q$ext\\E$
\\Q$extension\\E$
\\Q$f\\E
\\Q$file
\\Q$file syntax OK\\E$
\\Q$File::Find::topdir\\/
\\Q$File::Find::topdir\\E
\\Q$file\\E
\\Q$filename\\E
\\Q$filter
\\Q$find\\E
\\Q$first_caller\\E
\\Q$first_character$value$first_character\\E
\\Q$flag
\\Q$flags
\\Q$fn\\E
\\Q$format
\\Q$from\\E
\\Q$from\\E([^\\0]+)
\\Q$from_path\\E
\\Q$frompath\\E
\\Q$frompath\\E(.*?)\\0
\\Q$FS\\E
\\Q$fs\\E
\\Q$full\\E
\\Q$func
\\Q$g\\E
\\Q$g\\E$
\\Q$GAPCHAR
\\Q$gl
\\Q$grep\\E
\\Q$grep_pat\\E
\\Q$group_marker\\E
\\Q$h: $headers{$h}\\E(?:\\n|\\f|\\r)
\\Q$header\\E
\\Q$header\\E$
\\Q$header\\E\\Z
\\Q$HIGHLIGHT_STYLE\\E
\\Q$http_ext_id\\E
\\Q$char
\\Q$char\\E
\\Q$chunk\\E
\\Q$ignoring\\E
\\Q$image\\E
\\Q$implementation\\E
\\Q$indbr\\E$
\\Q$index_dir\\E/
\\Q$INPUT_RECORD_SEPARATOR\\E 
\\Q$inst_root
\\Q$installlibraryid\\E
\\Q$ISOLATE_CSS_RULE\\E
\\Q$item{incorrect}\\E
\\Q$j$i\\E
\\Q$k
\\Q$k\\E
\\Q$k\\E:
\\Q$key
\\Q$key\\E
\\Q$key_name\\E
\\Q$KEY_SEPARATOR\\E
\\Q$keyword\\E
\\Q$keyword\\E.*?($CLASS)->new
\\Q$keyword\\E.*?new ($CLASS)
\\Q$l
\\Q$L\\E\\s*(.*?)\\s*\\Q$R\\E
\\Q$label\\E\\n
\\Q$lang\\E
\\Q$last_part\\E$
\\Q$lc_db\\E
\\Q$lc_input\\E
\\Q$lead$lead$lead
\\Q$lib\\E/(.*_TEST)\\.pm$
\\Q$libruby
\\Q$line_sep\\E$
\\Q$Lingua::Wordnet::DELIM
\\Q$Lingua::Wordnet::SUBDELIM
\\Q$linktext\\E
\\Q$list
\\Q$listDelim\\E
\\Q$literal\\E
\\Q$long\\E\\z|\\Q$long_trail\\E\\z
\\Q$macro\\E
\\Q$MAGIC_NOLF\\E\\n
\\Q$main_xs_file\\E$
\\Q$mark\\E \\s+? $pattern
\\Q$mark1\\E
\\Q$mark2\\E
\\Q$marker
\\Q$marker\\E
\\Q$marker\\E(\\d+)\\0
\\Q$marker\\E\\s*([[:lower:]])
\\Q$match
\\Q$match\\E
\\Q$match\\E$
\\Q$me\\E
\\Q$method\\E
\\Q$model_name\\E$
\\Q$modpname.pm\\E$
\\Q$module
\\Q$msg
\\Q$msg\\E
\\Q$munge
\\Q$name
\\Q$name.\\E\\w{2,}$
\\Q$name\\E
\\Q$name\\E(?![\\[\\{])
\\Q$name_in\\E/
\\Q$name_sep\\E
\\Q$NAME_SEP\\E
\\Q$nbsp
\\Q$ne_cont\\E
\\Q$net_snmp_error\\E$
\\Q$newdependencypath\\E
\\Q$newpred
\\Q$next_boundary\\E\\r\\n
\\Q$nick
\\Q$no_domain\\E$
\\Q$no_proxy_domain\\E$
\\Q$null_pattern\\E
\\Q$num
\\Q$number
\\Q$o$c\\E
\\Q$o{I}\\E
\\Q$o->{font_suffix}\\E$
\\Q$odbclibdir
\\Q$odbchome
\\Q$OH/lib/
\\Q$OH/lib\\b
\\Q$old
\\Q$old\\E
\\Q$old_delimiter\\E
\\Q$old_encap_addr\\E
\\Q$old_expression\\E
\\Q$oldsubstate
\\Q$oldtext\\E
\\Q$omniholder
\\Q$op\\E
\\Q$open
\\Q$opendelim\\E
\\Q$opt{name}\\E
\\Q$option\\E
\\Q$opts{type}\\E$
\\Q$opts->{separator}\\E $
\\Q$orig_res\\E
\\Q$orig_sub
\\Q$origauth\\E$
\\Q$original_name\\E
\\Q$original_programs\\E
\\Q$originalTag\\E
\\Q$p_sep\\E
\\Q$p_sid
\\Q$p5p\\E
\\Q$package\\E$
\\Q$packet\\E
\\Q$packfn\\E\\z
\\Q$pair\\E
\\Q$params{contains}\\E
\\Q$parent_src_root
\\Q$parms[1]\\E
\\Q$parser->{POD_HTMLEASY}{MARK_FILTER}{MARK}\\E#(\\d+)#
\\Q$pat
\\Q$pat\\E
\\Q$path/\\E
\\Q$path;
\\Q$path\\E
\\Q$path\\E .
\\Q$path_info\\E$
\\Q$path_sep
\\Q$path_sep\\E
\\Q$path_separator
\\Q$pathPart\\E
\\Q$pattern\\E
\\Q$Pattern\\E
\\Q$perl
\\Q$perllibdir
\\Q$pgsig\\E
\\Q$phrase\\E
\\Q$pkg_dir\\E
\\Q$pkg_or_ver
\\Q$place_holder\\E
\\Q$placeholder
\\Q$plugin\\E$
\\Q$pmlcode\\E (.*?) \\Q$pmlcode\\E\n                          
\\Q$pmlcode\\E \"(.*?)\"\n                          
\\Q$pmlcode\\E\n                          
\\Q$pmlcode\\E\n                           =\"(.*?)\" (.*?) \\Q $pmlcode \\E\n                          
\\Q$possible\\E$
\\Q$pre_prefix\\E
\\Q$prefix\\E
\\Q$prefix->{$mode}
\\Q$prefSep\\E$
\\Q$prop->{value}
\\Q$ps\\E
\\Q$pv
\\Q$qstring\\E
\\Q$query
\\Q$quot\\E
\\Q$quote\\E
\\Q$quote_char
\\Q$quoter\\E
\\Q$r
\\Q$range\\E
\\Q$re\\E
\\Q$READ_DELIMITER
\\Q$regex\\E
\\Q$REGEX_TO_STRING_POSTFIX\\E$
\\Q$regexDelimiter\\E(.*)$
\\Q$regexDelimiter\\E.*$
\\Q$rel_file
\\Q$relayip\\E
\\Q$remote_ip\\E
\\Q$repl\\E
\\Q$replace
\\Q$replace\\E
\\Q$repositories{$_}{'LOCATION'}\\E
\\Q$rest\\E\\/?$
\\Q$result\\E\\s*$
\\Q$return\\E
\\Q$rev_id\\E
\\Q$root\\E
\\Q$root\\E.*/dp/
\\Q$root\\E::
\\Q$rperl_header_line
\\Q$RS\\E
\\Q$rs\\E
\\Q$rt\\E
\\Q$scalar\\E|hi
\\Q$search\\E
\\Q$search_str\\E
\\Q$search_term\\E
\\Q$searchstr
\\Q$section\\E
\\Q$seek\\E
\\Q$self->{'_DELIM'}\\E
\\Q$self->{_read}\\E
\\Q$self->{decimal_point}\\E
\\Q$self->{DELIMITER}\\E
\\Q$self->{EscapeSequence}\\E
\\Q$self->{Head}\\E([\\x00-\\xff]+)\\Q$self->{Tail}\\E
\\Q$self->{id_dir}\\E
\\Q$self->{ldap_inseparator}\\E
\\Q$self->{mon_decimal_point}\\E
\\Q$self->{multiValuesSeparator}\\E
\\Q$self->{multiValuesSeparator}\\E$
\\Q$self->{name_separator}\\E
\\Q$self->{name}\\E\\.$
\\Q$self->{path_col_sep}\\E
\\Q$self->{perl_lib_dir}\\E
\\Q$self->{portal}->{multiValuesSeparator}\\E$
\\Q$self->{quote_char}\\E$
\\Q$self->{'quote_instigator'}\\E
\\Q$self->{'quote_terminator'}\\E
\\\\\\Q$self->{'quote_terminator'}\\E
\\Q$self->{quote}\\E
\\Q$self->{sep}
\\Q$self->{SLASH_CHAR}\\E
\\Q$self->{SPACE_CHAR}\\E
\\Q$self->{thousands_separator}\\E
\\Q$self->{token}\\E
\\Q$self->{trigger}
\\Q$self->{urldc}\\E\\/?
\\Q$sep
\\Q$sep\\E
\\Q$sep\\E$
\\Q$SEP\\E$
\\Q$sep\\E(\\d+)$
\\Q$sep\\E+$
\\Q$sep_val\\E
\\Q$SEPARATOR
\\Q$separator\\E
\\Q$ship_name
\\Q$short\\E(.*)$
\\Q$sigils{$reftype}\\E
\\Q$sitedir\\E.
\\Q$snip\\E$
\\Q$snips[-1]$
\\Q$source\\E
\\Q$split_mark\\E
\\Q$src_root
\\Q$st
\\Q$star\\E(.*)\\Q$end\\E
\\Q$start\\E\\s*(.*?)\\s*\\Q$stop\\E
\\Q$start\\E\\s*(.+?)\\s*\\Q$end\\E
\\Q$start\\E\\s*.*?\\s*\\Q$stop\\E
\\Q$start_mark
\\Q$START_TOKEN\\E.*\\Q$END_TOKEN\\E\\n
\\Q$start_url\\E
\\Q$stop\\E(.*)
\\Q$stop_url\\E
\\Q$str\\E
\\Q$string\\E
\\Q$String\\E
\\Q$string\\E.*$
\\Q$strs[$str]\\E
\\Q$sub_with_sig\\E
\\Q$subbed
\\Q$SUBDELIM
\\Q$subj\\E
\\Q$subprefix\\E
\\Q$substitute_this
\\Q$suffix\\E$
\\Q$suffix\\E\\z
\\Q$symbol\\E
\\Q$symbol_db\\E
\\Q$t
\\Q$t1\\E
\\Q$t2\\E
\\Q$Tab{$key}\\E
\\Q$table\\E
\\Q$tag\\E
\\Q$tag\\E([^/]+)
\\Q$tag_open\\E(.*?)\\Q$tag_close\\E
\\Q$tag_sig\\E
\\Q$tagDelim\\E
\\Q$tagstack->[-1]\\E
\\Q$target\\E
\\Q$target\\E\"?$
\\Q$target_name\\E
\\Q$temp\\E
\\Q$template_dir\\/
\\Q$term_val\\E
\\Q$terminator\\E
\\Q$terminator->[1]\\E$
\\Q$testdir\\E/(.+)/TestSuite\\.html$
\\Q$ThousandsSeparator\\E
\\Q$thsd_sep\\E
\\Q$tld\\E$
\\Q$tmp\\E$
\\Q$tmpfile\\E
\\Q$tmx\\E-(.+)
\\Q$to\\E
\\Q$token\\E
\\Q$tool_label\\E result is '([^']+)'
-\\Q$trimmer\\E
\\Q$tstr\\E
\\Q$type
\\Q$type\\E$
\\Q$unsafe_arg\\E
\\Q$unsubbed
\\Q$updir\\E
\\Q$url\\E\n                         
\\Q$urn\\E$
\\Q$value\\E
\\Q$var\\E$
\\Q$variable\\E
\\Q$version\\E$
\\Q$violations_text
\\Q$voice\\E
\\Q$what\\E$
\\Q$whitespace\\E
\\Q$wholetag\\E
\\Q$wildcard
\\Q$words[-1]\\E$
\\Q$wpdir\\E\\/?
\\Q$x\\E
\\Q$xcodenew\\E
\\Q$xcodeold\\E
\\Q$z\\E
\\Q$ZERO\\E
\\Q&\\E.*?\\Q;\\E
\\Q&mdash;\\E
\\Q&nbsp;\\E
\\Q&quot;\\E
\\\\Q(.*?)\\\\E
\\Q(?^
\\Q(?^:
\\Q(?<foo>\\d+)  [  \\E(?<name>abc\\d+)  \\Q]\\E
\\Q(?<foo>\\d+)\\E (?<name>abc\\d+)
\\Q(?k:
\\Q(no filesize change)
\\Q(no IDAT change)
\\Q*
\\Q**\\E
\\Q,\\E
\\Q.$_\\E$
\\Q.$domain\\E$
\\Q..
\\Q...
\\Q.\\E
\\Q/*\\E.*?\\Q*/\\E
\\Q::\\E
\\Q;\\E
\\Q?>
\\Q@{[NBSP]}
\\Q[#SVAR \\E(.+?)\\Q#]\\E
\\Q[[$_]]
\\Q[[el]]
\\Q[{CONFIG}]
\\Q[{LIB}]
\\Q[l[$_]]
\\Q[l[el]]
\\Q[long options...]
\\Q\"\\E
\\Q\\$%\\E$
\\Q\\$sep\\E
\\Q\\;\\E(.*)$
\\Q\\\\\\E
\\\\Q\\\\E
\\\\\\Q\\\\E
\\Q\\n
\\Q\\n\\E
\\Q\\public\\ratlperl\\5.8.6\\nt_i386\\E
\\Q\\r
\\Q\\r\\n
\\Q]|[\\E
\\Q^failed^\\E
\\Q^made^\\E
\\Q_diary.pl\\E
\\Q`\\E
\\Q{%query%}\\E
\\Q{{amp}}
\\Q{{name}}\\E
\\Q{{perl}}\\E
\\Q{{var}}\\E
\\Q{cover_db_path}\\E
\\Q{interpreter_path}\\E
\\Q{libs}\\E
\\Q{twtfile}
\\Q{TYPE}: unrecognised attribute\\E
\\Q|$t2:\\E(.*?)\\|
\\Q|$type2:\\E(.*?)\\|
\\Q|\\E
\\Q||
\\Q<!-- COMMENT: start -->\\E(.*?)\\Q<!-- start : Loop -->\\E
\\Q<!-- MP3DATASPLIT -->\\E
\\Q<!-- start : Loop -->\\E(.*?)\\Q<!-- end : Loop -->\\E
\\Q<!--MATCHME-->\\E
\\Q<?
\\Q<b>description</b>\\E\\s+<u>(.+?)</u>
\\Q<CENTER><H1><a href=\"http://bioperl.org\">Bioperl</a> Reformatted HTML of BLASTN Search Report<br> for </H1></CENTER>\\E
\\Q<h3 class=\"title\">WEB\u00e3\u0082\u00a2\u00e3\u0082\u00af\u00e3\u0082\u00bb\u00e3\u0082\u00b9\u00e6\u0099\u0082 \u00ef\u00bc\u0088i\u00e3\u0083\u00a2\u00e3\u0083\u00bc\u00e3\u0083\u0089\u00e3\u0083\u0096\u00e3\u0083\u00a9\u00e3\u0082\u00a6\u00e3\u0082\u00b6\u00ef\u00bc\u0089</h3>\\E(.+)\\Q<h3 class=\"title\">WEB\u00e3\u0082\u00a2\u00e3\u0082\u00af\u00e3\u0082\u00bb\u00e3\u0082\u00b9\u00e6\u0099\u0082\u00ef\u00bc\u0088\u00e3\u0083\u0095\u00e3\u0083\u00ab\u00e3\u0083\u0096\u00e3\u0083\u00a9\u00e3\u0082\u00a6\u00e3\u0082\u00b6\u00ef\u00bc\u0089</h3>\\E
\\Q<title>[TL] \u00e5\u0086\u0085\u00e9\u0083\u00a8\u00e3\u0082\u00a8\u00e3\u0083\u00a9\u00e3\u0083\u00bc</title>\\E
\\Q<tr align=\"center\" bgcolor=\"#FFFFFF\">\\E(.*?)<\\/tr>\\s*\\Q<tr align=\"center\" bgcolor=\"#FFF4E0\">\\E(.*?)<\\/tr>
\\\\q=\"(.*?)\"(.*?)\\\\q\n              
\\\\Q=\"(.*?)\"\n              
\\Q'=bin='\\E
\\Q'=script='\\E
\\Qa^$bcabc\\E
\\Qabc\\Eefg\\\\Q\\\\Ehij
\\Qadd_diary.pl\\E
\\Qboxmuller\\E
\\Q'cite' => 'http://www.stonehenge.com/merlyn/'
\\Qcodeen.cs.princeton.edu\">CoDeeN
\\QcoreExtension>io.jenkins.tools.incrementals:git-changelist-maven-extension:\\E(.+)
\\Qdir1\\dir2\\E
\\Qdir1\\dir2\\\\E
\\QGo.\\E
\\QHTML/Mason.pm
\\Qhttp://www.ebi.ac.uk/chebi/searchId.do;?chebiId=\\E
\\Qhttp://www.ebi.ac.uk/chebi/searchId.do?chebiId=\\E
\\Qhttp://www.geneontology.org/formats/oboInOwl#\\E
\\Qhttp://www.helex.gr/content/en/Companies/ListedCo/Profiles/Profile.asp?cid=\\E(\\d+)
\\Q-l$lib\\E\\b
\\Qno such section
\\Qnow()\\E
\\Qrecently-used.xbel
\\Q-rw-r--r--\\E (.+) filemode\\.file
\\Qsend_message.pl\\E
\\QSPAN class=\"voteusrip\">(\\E(127.0.0.1)\\Q)<\\/SPAN>\\E
\\Q-std=c99\\E
\\QT5.6-009
\\Qtest.fixflo.com\\E
\\\\quarternote 
\\Qubic-watchdog ubic.watchdog\\E
\\\\quote\\\\
\\Q'url' => 'http://www.foo.com/foo.html'
\\QV5.5-004
\\Q-Wc++-compat
\\QWriteMakefileArgs{PREREQ_PM} = \\%FallbackPrereqs;\\E
\\R
\\R$
\\R.*
\\R?$
\\r?\\n[\\h]*
\\r?\\n--\\Q$b\\E--.*
\\r?\\n--\\Q$b\\E\\r?\\n
\\r?\\n--\\Q$b\\E--\\r?\\n.*
\r\n                    ^/               # comment started like /*/\r\n                    \\s*\r\n                    (\\S[\\s\\S]+?)  # has at least some non-ws content\r\n                    \\s*\r\n                    /\\*             # ends like /*/ or /**/\r\n                
\r\n        ( 
\\r\\n\\Q$code\\E-
\\\\r\\\\n|[\\\\r\\\\n\\\\t
\\r\\nHKEY_CURRENT_USER\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\User Shell Folders\\r\\n
\\R\\R
\\R\\R+
\\R\\s*\\R
\\R\\s+
\\R\\z
\\R{1,2}[\\t\\x20]*\\R{1,2}
\\R{2,}
\\R|$
\\R|\\]
\\R|=
\\R+
\\R+$
\\R+\\z
\\\\Rational
\\\\Real
\\\\Recent
\\REPLACE((?:[^\\\\\\REPLACE]|\\\\.)*)
\\REQ.IP.SOURCEIP == [0-9.]+
\\\\ReverseUpEquilibrium 
\\\\rhaco\\\\Exceptions::add\\(\\s*new\\s+([\\\\\\w]+)\\((.*?)\\)
\\\\Rho 
\\\\Rightarrow 
\\\\RightDownTeeVector 
\\\\RightDownVectorBar 
\\\\RightTeeVector 
\\\\RightTriangleBar 
\\\\RightUpDownVector 
\\\\RightUpTeeVector 
\\\\RightUpVectorBar 
\\\\RightVectorBar 
\\\\RoundImplies 
\\\\Rrightarrow 
\\\\Rsh 
\\\\ruby(\\{(?:
\\\\ruby\\{(?:
\\\\RuleDelayed 
\\s ([\\Q$ops\\E]+) \\s
\\s href \\s* = \\s* [\\\"']? \\Q$$url[2]\\E ([\\\"'>])\n\t\t           
\\s src \\s* = \\s* [\\\"']? \\Q$$url[2]\\E ([\\\"'>])\n\t\t           
\\s(?!\\\\)
\\s(?:href|src)\\s{,3}=\\s{,3}(?P<delim>['\"])(.*?)(?P=delim)
\\s(?P<fluff>.*?)`\\=(?P<context>\\S+?)\\([^\\)\\s]*?\\Z
\\s(?P<lib>\\S?/\\S+)\\s+\\((?P<addr>0x.+)\\)
\\s(?P<num>\\d+)\\s+(?P<name>(RPL|ERR)_\\w+)\\s*(?P<_>.*)
\\s([a-zA-Z][a-zA-Z0-9\\_\\.\\-]*[a-zA-Z]*\\@[a-zA-Z][a-zA-Z0-9\\_\\.\\-]*[a-zA-Z]{2,6})([\\s|\\.|\\,])
\\s(\\w*)\\s*=\\s*(?|\"([^\"]+)\"|'([^']+)'|([^\\s><'\"]+))
\\s(id|xlink:href)=\"(#?
\\s* (?<!\\\\) [|] \\s*
\\s* (\"(?:(?!(?<!\\\\)\").)*\" | '(?:(?!(?<!\\\\)').)*' | \\S+)
\\s*#.*?[^\\\\]\\s*\\n
\\s*#\\d++$
\\s*-#\\s*(
-\\s*#\\s*(
\\s*#\\s*include\\s+(?P<quote>[\"<])(?P<filename>.+?)[\">]
\\s*#\\s*pylint:\\s+disable=(?P<disables>[^#$]+?)(?=\\s*(#|$))
\\s*#+\\s*(?P<name>[^#\\n]+)([ \\r\\t\\v#]*)(?P<value>(.+?)(\\n(?!\\s#))|\\s*$)
\\s*#define[ \\t]+.*_width[ \\t]+(?P<width>[0-9]+)[\\r\\n]+#define[ \t]+.*_height[ \t]+(?P<height>[0-9]+)[\r\n]+(?P<hotspot>#define[ \t]+[^_]*_x_hot[ \t]+(?P<xhot>[0-9]+)[\r\n]+#define[ \t]+[^_]*_y_hot[ \t]+(?P<yhot>[0-9]+)[\r\n]+)?[\\000-\\377]*_bits\\[\\]
\\s*#define[ \t]+.*_width[ \t]+(?P<width>[0-9]+)[\r\n]+#define[ \t]+.*_height[ \t]+(?P<height>[0-9]+)[\r\n]+(?P<hotspot>#define[ \t]+[^_]*_x_hot[ \t]+(?P<xhot>[0-9]+)[\r\n]+#define[ \t]+[^_]*_y_hot[ \t]+(?P<yhot>[0-9]+)[\r\n]+)?[\\000-\\377]*_bits\\[\\]
\\s*#define\\s+(
\\s*(
\\s*'((?:[^']++|'')*+)'\\s*(?:,|$)
\\s*(([\"'])([\\s\\S]*?[^\\\\])\\2|[^,]+)\\s*
\\s*(/\\*+\\s|\\*+/|\\B\\*\\s?|///?!?)(?P<line>.*?)
\\s*(/\\*+\\s|\\*+/|\\B\\*\\s|///?!?)(?P<line>.*?)
\\s*(?:
\\s*(?:(?P<literal>[\\[\\]{}])|(?P<word>[a-zA-Z_]\\w*))
\\s*(?:([^\\s\\\\\\'\\\"]+)|'((?:[^\\'\\\\]|\\\\.)*)'|\"((?:[^\\\"\\\\]|\\\\.)*)\")
\\s*(?:(\")([^]*?)\"|(\\S+))\\s*
\\s*(?:(\"|')([^]*?)\\1|(\\S+))\\s*
\\s*(?:<p\\s*/?>)|(?:\\\\para(?:\\\\ )*)\\s*
\\s*(?<!\\\\)$delim.*
\\s*(?<!\\\\),\\s*
\\s*(?<!\\\\)/\\s*(.*)
\\s*(?<!\\\\);\\s*
\\s*(?<!\\\\)[\\s,]\\s*
\\s*(?<!\\\\)\\#.*$
\\s*(?P<addr>\\S*)\\s*\\<(?P<symbol>.*)\\>\\s*\\(File Offset:\\s*(?P<offset>\\S*)\\s*\\)
\\s*(?P<alias>[^\\s;]+)\\s*;?\\s*
\\s*(?P<arg_name>[a-zA-Z0-9_]+)\\s*=\\s*(?P<arg_type>[a-zA-Z]+)\\s*$
\\s*(?P<brackets>[\\'\"])(.*?)(?P=brackets)\\s*=>\\s*(?P=brackets)(.*?)(?P=brackets)
\\s*(?P<code>\\d+)
\\s*(?P<comm>.+) \\(\\s*(?P<pid>[0-9]+)\\/\\s*(?P<ppid>[0-9]+)\\/\\s*(?P<nrThreads>[0-9]+)\\/(?P<pri>.{4})\\)\\|\\s*(?P<cpu>\\S+)\\(.+\\)\\|\\s*(?P<vss>[0-9]+)\\(\\s*(?P<rss>[0-9]+)\\/.+\\)\\|\\s*(?P<blk>\\S+)\\(\\s*(?P<blkrd>.+)\\/\\s*(?P<blkwr>.+)\\/
\\s*(?P<comm>.+)\\(\\s*(?P<pid>[0-9]+)
\\s*(?P<command>\\S*)\\s*(?P<option>\\S*)
\\s*(?P<content>.*?)\\s*\\n
-\\s*(?P<control>elif|else)(?P<expr>.*)
-\\s*(?P<control>except|else|finally)(?P<expr>.*)
\\s*(?P<cpu>\\-*[0-9]+)\\s*%\\s*\\(\\s*(?P<user>\\-*[0-9]+)\\s*\\/s*\\s*(?P<kernel>\\-*[0-9]+)\\s*\\/s*\\s*(?P<block>\\-*[0-9]+)
\\s*(?P<date>\\d\\d\\d\\d-\\d\\d-\\d\\d)
\\s*(?P<free>\\-*[0-9]+)\\s*\\(\\s*(?P<freeDiff>\\-*[0-9]+)\\s*/\\s*(?P<anon>\\-*[0-9]+)\\s*/\\s*(?P<cache>\\-*[0-9]+)\\s*/\\s*(?P<kernel>\\-*[0-9]+)
\\s*(?P<gpu>.+)\\s*\\(\\s*(?P<usage>[0-9]+)\\s*%\\)
\\s*(?P<id>[A-Z0-9]+) /\\* (?P<isa>.*) \\*/ = {
\\s*(?P<id>[A-Z0-9]+) /\\* (?P<isa>.*) \\*/,
\\s*(?P<id>[A-Z0-9]+) /\\* (?P<name>.*) \\*/ = {
\\s*(?P<key>.*\\w)\\s*:\\s*(?P<value>.*)$
\\s*(?P<key>[\\w-]+)\\s*(?:=\\s*(?P<quote>[\"']?)(?P<value>.*?)(?P=quote)\\s*)?
-\\s*(?P<keyword>return|continue|break)\\s*
\\s*(?P<label>\\d+)\\s*(\\b|(?=&)|\\Z)
-\\s*(?P<lang>md|markdown|rst|rest|coffee|scss|sass|stylus)\\s*
\\s*(?P<left>[\\w\\.]+)\\s*=\\s*(?P<right>\\w+)\\s*
-\\s*(?P<line>(?:def|block)(?:\\s+.*)?)
-\\s*(?P<line>(?:include|inherit|page|namespace)(?:\\s+.*)?)
\\s*(?P<line>.*)\\s*\\n?
-\\s*(?P<line>call(?:\\s+.*)?)
-\\s*(?P<line>text(?:\\s+.*)?)
\\s*(?P<lt_or_gt>[<>]?)\\s*(?P<equals>=?)\\s*(?P<number>[0-9.]+)\\s*$
\\s*(?P<method_name>[a-zA-Z0-9._]+)\\s*(\\((?P<args_sig>[^)].*)?\\)\\s*(\\->\\s*(?P<return_sig>.*))?)?\\s*$
\\s*(?P<name>.+?)\\s*=\\s*(?P<module>[\\w.]+)\\s*(:\\s*(?P<attr>[\\w.]+))?\\s*(?P<extras>\\[.*\\])?\\s*$
\\s*(?P<name>[a-zA-Z0-9_]+)\\s*=\\s*(fudge\\.)?Fake\\(.*
\\s*(?P<name>\\S+)(\\s+(?P<attrs>[^#]+))?(\\s*#\\s*(?P<comment>.*)$)?
\\s*(?P<name>\\w[\\w\\d]*)\\s*=(?P<value>.*)
\\s*(?P<name>\\w+)\\s*:\\s*(\\b|(?=&)|\\Z)
\\s*(?P<operator>[<=>!]{1,2})?\\s*(?P<version>.+)\\s*
\\s*(?P<opt>\\[\\s*)?(?P<role>[^ ]+) (?P<value>[^ ,.{\\]]+)(?:\\s*\\{\\s*(?P<properties>[^ ]+ [^ ,}]+(?:, [^ ]+ [^ ,}]+)*)\\s*\\})?(?(opt)\\s*\\])(?:\\s*(?P<end>,|$)\\s*)
\\s*(?P<package>[^\\s\\[\\]]+)(?P<extras>\\[\\S+\\])?==(?P<version>\\S+)
\\s*(?P<param>\\w+).*:\\s*(?P<doc>[^\\n]+)
-\\s*(?P<python>py(?:thon)?(?P<excl>\\!?))(?P<expr>\\s+.*)?
\\s*(?P<rel>(?P<ver>\\d+\\.\\d+)(?:\\.\\S+)*)\\s*
\\s*(?P<selector>[#\\.\\w\\-\\s_]+)\\s*
\\s*(?P<selectors>[#\\.\\w\\-\\s,_]+)\\s*\\{\\s*(?P<declarations>[^}]+)\\}
\\s*(?P<schema>[a-z0-9]{3,9})://.*$
-\\s*(?P<stmnt>if|for|while|with|try)(?P<expr>.*)
-\\s*(?P<stmnt>unless|until)(?P<expr>.*)
\\s*(?P<swap>\\-*[0-9]+)
\\s*(?P<symbol>\\.|#)?(?P<name>[\\w-]+)\\s*
\\s*([\\*$~^|]?+=|[{};,>~]|!important\\b)\\s*
\\s*([^,=>\\\"\\']+?|           # word arg (yes, the => in the class is bad\n\t\t\t\t(\\\"|\\')(.*?(?<!\\\\))\\2   # quoted\n\t\t\t       )\\s*(?:,|=>|$)
\\s*([^:]*):\\s*([^#]*)\\s*#*\\s*([^\\z]*)
\\s*([^\\s]+)\\s*(?:->|?)((?:\\s*[^\\s(]+\\s*)+)\\s*(?:\\(([0-9](?:[.,][0-9]+)?)\\))?\\s*
\\s*(\\\\)?([>+~])(\\s*)
\\s*(\\}?)\\s*([^\\}\\{:\\\"\\s]+|$)\\s*(?:\\:\\s*\\\"((?:[^\\\"\\\\]|(?:\\\\.))*)\\\")?\\s*(\\{?)$
\\s*(\\\\9)\\s*
\\s*(\\b|(?!\\w))\\Q$c\\E$
\\s*(\\p{Punct})\\s*
\\s*(<(?:\\\\[<>]?|[^\\s<>\\\\])*>|(?:\\\\[()]?|\\([^\\s\\x00-\\x1f()\\\\]*\\)|[^\\s\\x00-\\x1f()\\\\])*?)
\\s*(<(?:\\\\[<>]?|[^\\s<>\\\\])*>|(?:\\\\[()]?|\\([^\\s\\x00-\\x1f\\\\]*\\)|[^\\s\\x00-\\x1f()\\\\])*?)
\\s*(0x[a-f0-9]+)\\s((?:\\Q(has no name)\\E)|(?:\\\".+\\\")):
\\s*(AND|OR)?\\s*([\\w_.()]++)\\s*(?:(=|<[=>]?|>=?|LIKE)\\s*((?>'(?>[^']++|'')*+'|[\\d-.()]+))|((NOT )?IN\\s*\\((?>'(?>[^']++|'')*+',? ?|[\\d-.]+,? ?)*+\\)))
\\s*(and|to|-|?)?\\s*
\\s*(MIN|MAX)(?P<name>.*)FEDID\\s*=\\s*(?P<id>[0-9]+).*
\\s*(order\\sby)|$)
\\s*:param\\s+(?P<param>\\w+):\\s*(?P<doc>[^\\n]+)
\\s*;\\s*(?<key>
\\s*;\\s*(?<name>
\\s*;\\s*(?P<text>.*)$
\\s*;\\s*(?P<value>.*)
\\s*;\\s*([\\w\\-.!%*_+`'~]+)(?:\\s*=\\s*([\\w\\-.!%*_+`'~]+|\"[^\"\\\\]*(\\\\.[^\"\\\\]*)*\"))?
\\s*;\\s*(filename|name)\\s*(?:\n      = \\s* \"((?>\\\\\"|[^\"])*)\"         # quoted string - v1\n      | = \\s* (
\\s*@(?P<type>\\S*)\\s*\\{\\s*(?P<key>\\S*)\\s*,.*
\\s*@param\\s+(?P<param>\\w+):\\s*(?P<doc>[^\\n]+)
\\s*[\\s,;:/\\\\]+\\s*
\\s*[\\w.]+=(?:[\\w.]+|\"(?:[^\"\\\\]|\\\\.)*\")?\\s*
\\s*[a-zA-Z\\/\\/:\\.]*youtube.com\\/watch\\?v=([a-zA-Z0-9\\-_]+)([a-zA-Z0-9\\/\\*\\-\\_\\?\\&\\;\\%\\=\\.]*)
\\s*[float|vec2|vec3|vec4]?\\s+([\\w|\\_]*)[\\.\\w]*?\\s+[\\+|\\-|\\\\|\\*]?\\=
\\s*\\\\